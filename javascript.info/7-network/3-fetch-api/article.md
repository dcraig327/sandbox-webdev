
# Fetch API

TODO: FormData in detail https://xhr.spec.whatwg.org/#formdata?

The second argument provides a lot of flexibility to `fetch` syntax.

Here's the full list of possible options with default values (alternatives commented out):

```js
let promise = fetch(url, {
  method: "GET", // POST, PUT, DELETE, etc.
  headers: {
    "Content-Type": "text/plain;charset=UTF-8" // for a string body, depends on body
  },
  body: undefined // string, FormData, Blob, BufferSource, or URLSearchParams
  referrer: "about:client", // "" for no-referrer, or an url from the current origin
  referrerPolicy: "no-referrer-when-downgrade", // no-referrer, origin, same-origin...
  mode: "cors", // same-origin, no-cors
  credentials: "same-origin", // omit, include
  cache: "default", // no-store, reload, no-cache, force-cache, or only-if-cached
  redirect: "follow", // manual, error
  integrity: "", // a hash, like "sha256-abcdef1234567890"
  keepalive: false, // true
  signal: undefined, // AbortController to abort request
  window: window // null
});
```

An impressive list, right? A lot of capabilities.

Let's explore what `fetch` can do.

We'll explore the options one-by-one with examples.

## method, headers, body

These are the most widely used fields.

- **`method`** -- HTTP-method, e.g. `POST`,
- **`headers`** -- an object with HTTP headers,
- **`body`** -- a string, or:
  - FormData object, to submit `form/multipart`
  - Blob/BufferSource to send binary data
  - URLSearchParams, to submit `x-www-form-urlencoded`

For instance, to submit a `user` object as JSON:

```js run async
let user = {
  name: 'John',
  surname: 'Smith'
};

*!*
let response = await fetch('/article/fetch-api/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});
*/!*

let result = await response.json();
alert(JSON.stringify(result, null, 2));
```

Please note, for a string body `Content-Type` is `text/plain;charset=UTF-8` by default. So the correct header is set manually.

Let's do the same with an HTML `<form>`:

```html run
<form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
</form>

<script>
fetch('/article/fetch-api/post/user', {
  method: 'POST',
  body: new FormData(formElem)
})
  .then(response => response.json())
  .then(result => alert(JSON.stringify(result, null, 2)))
</script>
```

Here [FormData](https://xhr.spec.whatwg.org/#formdata) automatically encodes the form (with files if any), and the `Content-Type` is `form/multipart`.

We can also submit binary data directly using `Blob` or `BufferSource`.

For example, here's a `<canvas>` where we can draw by moving a mouse. A click on the "submit" button sends the image to server:

```html run autorun height="90"
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    function submit() {
      canvasElem.toBlob(function(blob) {        
        fetch('/article/fetch-api/post/image', {
          method: 'POST',
          body: blob
        })
          .then(response => response.json())
          .then(result => alert(JSON.stringify(result, null, 2)))
      }, 'image/png');
    }

  </script>
</body>
```

Here we also didn't need to set `Content-Type` manually, because a `Blob` object has a built-in type (here `image/png`, as generated by `toBlob`).

```warn header="Not any header is allowed"
There's a list of [forbidden HTTP headers](https://fetch.spec.whatwg.org/#forbidden-header-name) that we can't set:

- `Accept-Charset`, `Accept-Encoding`
- `Access-Control-Request-Headers`
- `Access-Control-Request-Method`
- `Connection`
- `Content-Length`
- `Cookie`, `Cookie2`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`
- `Proxy-*`
- `Sec-*`

All these headers are controlled solely by the browser, to ensure proper and safe HTTP. So we can't set them.
```

## referrer, referrerPolicy

These options govern how `fetch` sets HTTP `Referer` header (header has one `r`, for historical reasons).

That header tells the server which page made the request. In most scenarios, it plays a very minor informational role, so if you don't have specific reasons to care about it, like increased security, please skip to the next section.

- **`"no-referrer-when-downgrade"`** -- default value, the referer is set always, unless we send a request from HTTPS to HTTP (to less secure protocol).
- **`"no-referrer"`** -- don't set the referer.
- **`"origin"`** -- only set the domain, not the full page URL, e.g. `http://site.com` instead of `http://site.com/path`.

no-referrer
The Referer header will be omitted entirely. No referrer information is sent along with requests.
 (default)
This is the user agent's default behavior if no policy is specified. The URL is sent as a referrer when the protocol security level stays the same (HTTP→HTTP, HTTPS→HTTPS), but isn't sent to a less secure destination (HTTPS→HTTP).
