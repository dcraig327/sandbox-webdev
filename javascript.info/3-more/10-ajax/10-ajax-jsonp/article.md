# JSONP, получение данных через SCRIPT

Если создать узел `SCRIPT` со ссылкой на внешний исходник, то при добавлении в документ запустится процесс загрузки. В ответ сервер может прислать скрипт, содержащий нужные данные.

Основным преимуществом такого способа коммуникации является кросс-браузерность и возможность обратиться к любому домену. 

[cut]

## Запрос SCRIPT

Простейший пример запроса:

```js
function attachScript(src) {
  var elem = document.createElement("script");
  elem.src = src;
  document.getElementsByTagName('head')[0].appendChild(elem);
}

attachScript('/user.php?id=123');
```

Такой вызов добавит в `HEAD` документа тег:

```js
<script src="/user.php?id=123"></script>
```

Браузер тут же обработает его: запросит `/user.php?id=123` с заданного URL и выполнит. 

## Обработка ответа, JSONP

В примере выше рассмотрено создание запроса, но как получить ответ? Самый простой способ -- это присвоить его в переменную, т.е. сервер ответит как-то так:

```js
var response = "....";
```

...А браузер по `script.onload` отловит окончание загрузки и получит значение `response`.

Но что, если одновременно делается несколько запросов? Получается, нужно присваивать в разные переменные.

Для большей гибкости при ответе используется протокол `JSONP`.

**При этом название функции браузер может передать вместе с запросом.**

Запрос:

```js
attachScript('/user.php?id=123&*!*callback=onUserData*/!*');
```

Cервер кодирует данные как JavaScript-объект и оборачивает их в функцию, название которой получает из параметра `callback`:

```js
onUserData({
  name: "Вася",
  age: 25,
  isAdmin: false
});
```

**Формат запроса, когда JSON заворачивается в функцию, называется JSONP ("JSON with Padding").**

[warn header="Аспекты безопасности"]
<ol>
<li>При кросс-доменном получении скрипта JavaScript не имеет доступа к его тексту.</li>
<li>Клиентский код должен доверять серверу при таком запросе. Ведь серверу ничего не стоит добавить в скрипт любые команды.</li>
</ol>
[/warn]

## Реестр CallbackRegistry

В примере выше функция `onUserData` должна быть глобальной, иначе скрипт её не увидит. 

Хотелось бы не загрязнять глобальное пространство имён и вызывать транспорт с локальной или даже анонимной функцией, как-то так:

```js
scriptRequest("/user.php?id=123", function(data) {
  /* обработать данные */
});
```

**Чтобы решить эти задачи, для каждого запроса генерируется временная функция и записывается в глобальный объект ("реестр").**

Тег будет выглядеть так:

```html
<script src="/user.php?id=123&callback=*!*CallbackRegistry.func12345*/!*"></script>
```

Сервер обернёт ответ в функцию `CallbackRegistry.func12345`, она вызывает нужный обработчик и очищает память, удаляя себя.

Далее мы посмотрим код всего этого, но перед этим -- важный момент! Нужно предусмотреть обработку ошибок.

## Обнаружение ошибок 

При запросе данных при помощи `SCRIPT` возможны различные ошибки:

<ol>
<li>Скрипт может не загрузиться: отказ в соединении, разрыв связи...</li>
<li>Ошибка HTTP, например 500.</li>
<li>Скрипт загрузился, но внутри некорректен и не вызывает функцию. Например, на сервере произошла ошибка и в ответе передан её текст, а вовсе не данные.</li>
</ol>

Чтобы отловить их все "одним махом", используем следующий алгоритм:

<ol>
<li>Создаётся `SCRIPT`.</li>
<li>На `SCRIPT` ставятся обработчики `onreadystatechange` (для старых IE) и `onload/onerror` (для остальных браузеров).</li>
<li>При загрузке скрипт выполняет функцию-коллбэк `CallbackRegistry...`. Пусть она при запуске ставит флажок "все ок". А мы в обработчиках проверим -- если флага нет, то функция не вызывалась -- стало быть, ошибка при загрузке или содержимое скрипта некорректно.</li>
</ol>

## Полный код

Итак, код. Он совсем небольшой, а без комментариев был бы ещё меньше:

```js
//+ src="scriptRequest.js"
```

Серверный скрипт отсылает ответ примерно так:

```js
var url = require('url');
var params = url.parse(req.url, true).query;

var data = { 
  name: "Вася",  
  age: 30 // данные из базы 
}

res.end(params.callback + '(' + JSON.stringify(data) + ')' );
```

### Демо

Пример "в действии" с тремя запросами -- правильным и двумя ошибочными:

```js
//+ run
function ok(data) {
  alert("Загружен пользователь " + data.name);
}

function fail(url) {
  alert('Ошибка при запросе ' + url);
}

// Внимание! Ответы могут приходить в любой последовательности!
scriptRequest("/files/tutorial/ajax/jsonp/user?id=123", ok, fail); // Загружен
scriptRequest("/badurl.js", ok, fail); // fail, 404
scriptRequest("/", ok, fail); // fail, 200 но некорректный скрипт
```

Функция `scriptRequest` в том или ином виде, иногда урезанном, реализована в различных фреймворках. В неё можно добавить более точное сообщение об ошибке, отправку данных и т.п.

## COMET


COMET через `SCRIPT` реализуется при помощи длинных опросов, также как мы обсуждали в главе [](/xhr-longpoll).

То есть, создаётся тег `<script>`, браузер запрашивает скрипт у сервера и... Сервер оставляет соединение висеть, пока не появится, что сказать. Когда сервер хочет отправить сообщение -- он отвечает, используя формат JSONP. И, тут же, новый запрос...
[head]
<script src="/files/tutorial/ajax/jsonp/scriptRequest.js"></script>
[/head]