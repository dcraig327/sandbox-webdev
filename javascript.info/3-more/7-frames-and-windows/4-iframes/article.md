# Общение с окном в ифрейме 

Здесь предполагается, что мы прекрасно знаем, что такое ифрейм, и как подключить внешний документ с его использованием. Иначе говоря, HTML для нас не нов.

В этой главе мы рассмотрим способы работы с ними из JavaScript.

[cut]

## Ифрейм: тонкости с атрибутами

Хоть мы и знаем, что такое ифрейм, но позвольте заострить внимание на нескольких моментах, касающихся атрибутов.

<dl>
<dt>Рамка: `frameborder="0"`</dt>
<dd>Если хочется, чтобы в IE<9 вокруг ифреймов не было рамок, то поставьте атрибут `frameborder="0"`.

В IE<9 все ифреймы в примере ниже, кроме последнего, будут с рамкой:

```html
<!--+ run -->
<style> iframe { width: 100px; height:40px } </style>
<ol>
  <li><iframe src="javascript:'тест'"></iframe></li>
  <li><iframe src="javascript:'тест'" style="border:0"></iframe></li>
*!*
  <li><iframe src="javascript:'тест'" frameborder="0"></iframe></li>
*/!*
</ol>
```

</dd>
<dt>Пустой `src`</dt>
<dd>Атрибут `src` может использовать протокол `javascript:...`. При этом код выполняется и его результат будет содержимым ифрейма. Этот способ описан в стандарте и поддерживается всеми браузерами.

Атрибут `src` является обязательным, и его отсутствие может привести к проблемам, вплоть до игнорирования ифрейма браузером. 

**Чтобы ничего не загружать в ифрейм, укажите `src="javascript:false"`.** 
</dd>
<dt>Атрибут `name` и создание ифрейма в IE<8</dt>
<dd>В старых IE нельзя менять атрибут `name` после создания ифрейма:

```js
var iframe = document.createElement('iframe');
iframe.name = 'iName'; // в IE<8 не сработает
```

Поэтому, если нужна совместимость, создавайте ифреймы через `innerHTML`:

```js
var tmp = document.createElement('div');
tmp.innerHTML = '<iframe name="iName" src="javascript:false"></iframe>';

var iframe = tmp.firstChild;
```

</dd>
</dl>

## Ифрейм: доступ к document и window

Элемент `iframe` является обычным узлом DOM, как и любой другой. Существенное отличие -- в том, что с ним связан объект `window` внутреннего окна. Он доступен по ссылке `iframe.contentWindow`.

Таким образом, `iframe.contentWindow.document` будет внутренним документом.

[smart header="Когда-то..."]
В старых браузерах использовались дополнительные свойства, такие как `iframe.contentDocument` и даже `iframe.document`, но они давно не нужны.
[/smart]

В примере ниже JavaScript получает документ внутри ифрейма и модифицирует его:

```html
<!--+ height="100" run -->
<iframe src="javascript:'тест'" style="height:60px"></iframe>

<script>
  var iframe = document.getElementsByTagName('iframe')[0];
*!*
  var iframeDoc = iframe.contentWindow.document;
*/!*
  iframeDoc.body.style.backgroundColor = 'green';
</script>
```

[smart]
Обратите внимание, HTML `'тест'` в примере выше -- невалидный, там нет `BODY`. Поэтому ифрейм будет отображаться в режиме совместимости.

Но браузер исправляет структуру и гарантирует, что после загрузки документа у него всегда есть `document.body` и ровно одно.
[/smart]

В целях безопасности возможность доступа к документу в ифрейме ограничена. Если он с другого домена, на другом порту или протоколе, то доступ запрещён. Подробнее об этом ограничении и как его можно обойти -- далее, в главе [](/same-origin-policy).

## Иерархия window.frames   

Альтернативный способ доступа к окну ифрейма -- это получить его из коллекции `window.frames`.

Есть два способа доступа:
<ol>
<li>`window.frames[0]` -- доступ по номеру.</li>
<li>`window.frames.iframeName` -- доступ по `name` ифрейма.</li>
</ol>

В коллекции хранится именно окно (`contentWindow`), а не тег.

Например:

```html
<!--+ run -->
<iframe src="javascript:''" style="height:80px" name="iframeName"></iframe>

<script>  
  var iframe = document.body.children[0];
  var iframeWindow = iframe.contentWindow; // окно из тега

  alert(frames[0] === iframeWindow); // true, окно из коллекции frames
  alert(frames.iframeName == iframeWindow); // true, окно из frames по имени
</script>
```

Внутри ифрейма могут быть свои вложенные ифреймы. Всё это вместе образует иерархию.

Ссылки для навигации по ней:

<ul>
<li>**По детям:** `window.frames` -- коллекция "детей" (вложенных ифреймов)</li>
<li>**На родителя:** `window.parent` -- содержит ссылку на родительское окно, позволяет обратиться к нему из ифрейма.

Всегда верно:

```js
// (из окна со фреймом)
window.frames[0].parent === window; // true
```

</li>
<li>**На корень:** `window.top` -- содержит ссылку на самое верхнее окно.

Всегда верно:

```js
// (в предположении, что вложенные фреймы существуют)
window.frames[0].frames[0].frames[0].top === window
```

</li>
</ul>

**Свойство `top` позволяет легко проверить, во фрейме ли находится текущий документ:**

```js
//+ run
if (window == top) {
  alert('Этот скрипт является окном верхнего уровня в браузере');
} else {
  alert('Этот скрипт исполняется во фрейме!');
}
```

## Событие onload 

У ифрейма есть своё событие `onload`, которое не связано с `onload` основного окна.

Иными словами, `onload` основного окна не ждёт, пока ифрейм догрузится.

**Событие `onload` есть и на теге `iframe` и на его окне.**

Это важно, так как обработчик на теге более универсален. 

**В случае, когда документ с другого домена, внешний документ сможет отследить его загрузку только по `onload` на теге.**

Например, попытаемся отследить загрузку ифрейма с сайта `http://vk.com/`:

```html
<!--+ run -->
<iframe src="http://vk.com/" name="vk" style="height:100px"></iframe>

<script>
  // поставить onload на элемент
  document.getElementsByTagName('iframe')[0].onload = function() {
    alert('Фрейм загрузился')
  }

  // set onload on window
  frames.vk.onload = function() {
    alert('Окно фрейма загрузилось')
  }
</script>
```

Запустите пример выше. Вы увидите, что работает только `iframe.onload`. А если бы ифрейм был с того же домена, то сработали бы оба обработчика.


## Атрибуты seamless и sandbox 

В стандарте HTML5 для [iframe](http://www.w3.org/wiki/HTML/Elements/iframe) предусмотрены атрибуты `seamless` и `sandbox`. 

Оба они на момент написания (конец 2012) поддерживаются в Chrome, в других браузерах поддержка тоже не за горами.

### seamless

Атрибут `seamless` полностью интегрирует ифрейм в документ, убирая рамку и применяя CSS-стили внешнего окна к содержимому ифрейма, как будто это обычный элемент.

То есть, если в основном документе есть стиль `p { font-weight: bold }`, то он повлияет и на содержимое ифрейма.

Для JavaScript он не важен.

### sandbox

Атрибут `sandbox` позволяет построить "песочницу" вокруг ифрейма, запретив ему выполнять ряд действий.

Наличие атрибута `sandbox`:
<ul>
<li>Заставляет браузер считать ифрейм загруженным с другого домена, так что он и внешнее окно больше не могут обращаться к переменным друг друга.</li>
<li>Отключает формы и скрипты в ифрейме.</li>
<li>Запрещает менять `parent.location` из ифрейма.</li>
</ul>

Пример ниже загружает в такой ифрейм документ:

```html
<!--+ run height=200 -->
<iframe *!*sandbox*/!* src="/files/tutorial/window/sandboxed.html"></iframe>
```

Содержимое файла `sandboxed.html`:

```html
<script>
  alert(1);
</script>

<form action="http://google.ru">
  <input type="submit" value="Отправить форму на http://google.ru">
</form>
```

Запустите пример выше для просмотра. Ни форма ни скрипты не сработают.

**Атрибут `sandbox` может содержать флаги через пробел, которые убирают ограничения:**
<dl>
<dt>allow-same-origin</dt>
<dd>Браузер может не считать документ в ифрейме пришедшим с другого же домена. Если ифрейм *и так* с другого домена, то ничего не меняется.</dd>
<dt>allow-top-navigation</dt>
<dd>Разрешает ифрейму менять `parent.location`.</dd>
<dt>allow-forms</dt>
<dd>Разрешает отправлять формы из `iframe`.</dd>
<dt>allow-scripts</dt>
<dd>Разрешает выполнение скриптов из ифрейма. Но скриптам, всё же, будет запрещено открывать попапы.</dd>
</dl>

Цель атрибута `sandbox` -- наложить дополнительные ограничения. Он не может снять уже существующие, в частности, убрать ограничения безопасности, если ифрейм с другого домена. 