# IFRAME для длинных соединений

Реализация COMET, рассматриваемая здесь, подходит для IE9- и других старых браузеров, не поддерживающих специализированный стандарт WebSocket.

Бесконечный IFRAME -- самый старый способ организации COMET. Когда-то он был основой AJAX-приложений, а сейчас -- используется лишь в случаях, когда браузер не поддерживает современный стандарт WebSocket.
[cut]

Этот способ основан на том, что браузер читает страницу последовательно и обрабатывает все новые теги по мере того, как сервер их присылает.

Классическая реализация -- это когда клиент создает невидимый IFRAME, ведущий на служебный URL. Сервер, получив соединение на этот URL, не закрывает его, а
время от времени присылает блоки сообщений <code>&lt;script&gt;...javascript...&lt;/script&gt;</code>. Появившийся в IFRAME'е javascript тут же выполняется браузером, передавая информацию на основную страницу.

Таким образом, для передачи данных используется "бесконечный" ифрейм, через который сервер присылает все новые данные. 

## Схема работы


Принцип работы: 
<ol>
<li>Создаётся `<iframe src="COMET_URL">`, по адресу `COMET_URL` расположен сервер.</li>
<li>Сервер выдаёт начало ("шапку") документа и останавливается, оставляя соединение активным.</li>
<li>Когда сервер хочет что-то отправить -- он пишет в соединение <code>&lt;script&gt;parent.onMessage(сообщение)&lt;/script&gt;</code> Браузер тут же выполняет этот скрипт -- так сообщение приходит на клиент.</li>
<li>Ифрейм, в теории, грузится бесконечно. Его завершение означает обрыв канала связи. Его можно поймать по `iframe.onload` и заново открыть соединение (создать новый `iframe`).</li>
</ol>

Также ифрейм можно пересоздавать время от времени, для очистки памяти от старых сообщений.

<img src="comet.png">

Ифрейм работает только на получение данных. Для запросов используется обычный `XMLHttpRequest`.

## Проблемы, специфичные для IFRAME

Такое использование ифреймов является хаком. Поэтому есть ряд проблем:

<ol>
<li>Показывается индикатор загрузки, "курсор-часики".</li>
<li>`IFRAME` влияет на историю посещений, если неправильно создан.</li>
<li>Браузер буферизует начало страницы.</li>
</ol>

Как обойти первые две проблемы в IE6-9 (именно для него в первую очередь и нужен IFRAME), мы видели в главе [](/ajax-iframe-htmlfile).

Что же касается буферизации -- IE не начинает обработку страницы, пока она не загрузится до определенного размера.

Поэтому в таком `IFRAME` первые несколько сообщений задержатся:

```html
<!DOCTYPE HTML>
<html>
  <body>
  <script>parent.onMessage("привет");</script>
  <script>parent.onMessage("от сервера");</script>
  ...
```

Решение -- забить начало ифрейма чем-нибудь, поставить, например, килобайт пробелов в начале:

```html
<!DOCTYPE HTML>
<html>
  <body>
  ******* 1 килобайт пробелов, а потом уже сообщения ******
  <script>parent.onMessage("привет");</script>
  <script>parent.onMessage("от сервера");</script>
  ...
```

## Код

Клиентский код, кросс-браузерно реализующий этот подход с возобновлением соединения при ошибках:

```js
//+ src="iframeComet.js"
```

Его можно улучшить, например сервер может раз в секунду посылать мини-сообщение "я тут", для более надёжного определения статуса подключения.

## Скачать пример

Мини-приложение с сервером на Node.JS, непрерывно получающее текущее время с сервера через `IFRAME`, можно скачать: [comet.zip](/zip/tutorial/ajax/iframe/comet.zip).


[head]
<script src="/files/tutorial/ajax/script/scriptRequest.js"></script>
[/head]