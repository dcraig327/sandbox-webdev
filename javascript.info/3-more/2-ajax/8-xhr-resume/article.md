# XMLHttpRequest: возобновляемая закачка

Современный `XMLHttpRequest` даёт возможность загружать файл как угодно: во множество потоков, с догрузкой, с подсчётом контрольной суммы и т.п.

Здесь мы рассмотрим общий подход к организации загрузки, а его уже можно расширять, адаптировать к своему фреймворку и так далее. 

Поддержка -- все браузеры кроме IE9-.

[cut]

## Неточный upload.onprogress

Ранее мы рассматривали загрузку с индикатором прогресса. Казалось бы, сделать возобновляемую загрузку на его основе очень просто. 

Есть же `xhr.upload.onprogress` -- ставим на него обработчик, по свойству `loaded`  события `onprogress` смотрим, сколько байт загрузилось. А при обрыве -- возобновляем загрузку с последнего байта. 

[smart]
К счастью, отослать на сервер нужный отрезок файла -- не проблема, [File API](http://www.w3.org/TR/FileAPI/) позволяет прочитать выбранный участок из файла и отправить его.

Примерно так:

```js
var slice = file.slice(10, 100); // прочитать байты с 10го по 99й включительно

xhr.send(slice); // ... и отправить эти байты в запросе.
```

[/smart]

..Но такая модель не жизнеспособна! 

Всё дело в том, что `upload.onprogress` срабатывает, когда байты *отправлены*, но были ли они получены сервером -- браузер не знает. Может, их прокси-сервер забуферизовал, может серверный процесс "упал" в процессе обработки, может соединение порвалось и байты так и не дошли до получателя. 

**Поэтому `onprogress` годится лишь для красивенького рисования прогресса.**

Для загрузки нам нужно точно знать количество загруженных байт. Это может сообщить только сервер.

## Общий вид загрузки

Мы разберём несколько способов надёжной загрузки. 

У них будет общим объект `Uploader` для загрузки, который имеет примерно следующий вид:

```js
function Uploader(file, onSuccess, onFail, onProgress) {
  
  var uploadId = Math.random();
  var startByte = 0;

  var fileId = file.name + '-' + file.size + '-' + (+file.lastModifiedDate);
  
  var errorCount = 0; 
  var MAX_ERROR_COUNT = 6;

  function upload() {
    ...
  }

  function pause() {
    ...
  }

  function resume() {
    ...
  }

  this.upload = upload;
  this.pause = pause;
  this.resume = resume;

}
```

Это -- самый общий интерфейс, разберём его подробнее.

Аргументы:
<dl>
<dt>`file`</dt>
<dd>Объект File API. Может быть получен из формы, либо как результат Drag'n'Drop.<dd>
<dt>`onSuccess`, `onFail`, `onProgress`</dt>
<dd>Функции-коллбэки, которые будут вызываться в процессе (`onProgress`) и при окончании загрузки.</dd>
</dl>

Используемые переменные:

<dl>
<dt>`uploadId`</dt>
<dd>Уникальный идентификатор загрузки. Генерируется случайно. Передаётся на сервер в начале загрузки и при её возобновлении, чтобы сервер знал, что это тот же файл.</dd>
<dt>`startByte`</dt>
<dd>С какого байта загружать. Изначально -- с нулевого.</dd>
<dt>`fileId`</dt>
<dd>Идентификатор файла, основанный на его имени, размере и дате модификации. 

По нему текущее состояние загрузки (`uploadId` и `startByte`) можно сохранить в `localStorage`, так что даже при закрытии браузера, а затем открытии и повторной загрузке того же файла -- браузер сможет продолжить загрузку.</dd>
<dt>`errorCount / MAX_ERROR_COUNT`</dt>
<dd>Число ошибок / максимальное число непрерывных ошибок, после которого загрузка считается проваленной.</dd>
</dl>

Использование:

```js
var uploader = new Uploader(form.elements.file.files[0], ...);

uploader.upload(); // загружает с возобновлением
uploader.pause();  // пауза
uploader.resume(); // возобновление загрузки
```

## Способ 1: спрашиваем сервер

Первый способ:

<ol>
<li>Функция `upload` загружает файл обычным образом. При ошибке, если это ещё возможно, вызываем `resume`:

```js
function upload() {
  
  xhrUpload = new XMLHttpRequest();
  xhrUpload.onload = xhrUpload.onerror = function() {

    if (this.status == 200) {
      // успешное завершение загрузки
      onSuccess();
      return; 
    }

    // что-то не так
    if (errorCount++ < MAX_ERROR_COUNT) {
      setTimeout(resume, 1000); // через 1 сек пробуем ещё раз
    } else {
      onError(this.statusText);  
    }     
  };

  xhrUpload.open("POST", "upload", true); 
  // какой файл догружаем /загружаем
  xhrUpload.setRequestHeader('X-Upload-Id', uploadId); 
  // с какого байта (сервер сверит со своим размером для надёжности)
  xhrUpload.setRequestHeader('X-Start-Byte', startByte); 
  // полный размер загружаемого файла
  xhrUpload.setRequestHeader('X-File-Size', file.size);

  xhrUpload.upload.onprogress = function(e) {
    errorCount = 0; 
    onProgress( startByte + e.loaded, startByte + e.total);
  }

  // отослать, начиная с байта startByte
  xhrUpload.send(file.slice(startByte));   
}
```

</li>
<li>При ошибке загрузка возобновляется. Но достоверной информацией о том, сколько байт получено, обладает лишь сервер. 

Функция `resume` спрашивает его об этом запросом `XMLHttpRequest`, а затем возобновляет загрузку:

```js
function resume() {
  xhrStatus = new XMLHttpRequest();

  xhrStatus.onload = xhrStatus.onerror = function() {
    if (this.status == 200) {
      startByte = +this.responseText || 0;
      upload();
      return;
    }

    // что-то не так
    if (errorCount++ < MAX_ERROR_COUNT) {
      setTimeout(resume, 1000); // через 1 сек пробуем ещё раз
    } else {
      onError(this.statusText);  
    }  
  };

  xhrStatus.open("GET", "status", true); 
  xhrStatus.setRequestHeader('X-Upload-Id', uploadId);
  xhrStatus.send('');
}
```

</li>
<li>Пауза-возобновление делаются просто:

```js
function pause() {
  // обрываем все запросы
  xhrStatus && xhrStatus.abort();
  xhrUpload && xhrUpload.abort();
}
```

</li>
</ol>

### Демо

[iframe src="upload-resume" link zip border="1" height="160"]

Полный код включает также сервер на Node.JS с функциям `onUpload` -- начало и возобновление загрузки, а также `onStatus` -- для получения состояния загрузки.

## Способ 2: статус с сервера

Предыдущий способ -- прост и хорош. Но для лучшего понимания рассмотрим ещё одну реализацию, которая более точна. 

Событие `upload.onprogress`, которое используется для отображения прогресса загрузки -- неточное. Как мы говорили, оно использует данные браузера, а он не может знать, были ли данные успешно получены и, что самое главное, корректно обработаны сервером.

Может быть такое, что индикатор показывает "100%", а на самом деле последний фрагмент ещё не загрузился.

В большинстве случаев эта неточность вполне допустима. Но бывают ситуации, когда мы не имеем права показывать посетителю неточную информацию.

**Описанный далее способ гарантирует точную информацию о процессе загрузке, цена -- дополнительный запрос.**

[warn header="Почему нужен ещё один запрос?"]
Первая идея, которая может прийти в голову -- это получать информацию о состоянии закачки из `xhr.onprogress`, то есть сервер должен при каждом полученном пакете байт писать полученную длину в ответ. 

Звучит хорошо, но, к сожалению, в `XMLHttpRequest` браузер *сначала* закачивает данные, а *потом* читает. То есть, сначала сработают события `xhr.upload.onprogress`, `xhr.upload.onload`, а уже затем пойдут события на получение данных: `xhr.onprogress`, `xhr.onload` и другие. Браузер получит ответ сервера целиком уже после окончания загрузки, а нам прогресс нужен -- во время загрузки.
[/warn]

Будем использовать два запроса: в одном -- закачивать, в другом -- читать прогресс с сервера.

<ul>
<li>Функция `runUpload` будет открывать запрос `xhrUpload`, который отправляет данные на сервер. У него даже не будет `onprogress`, всю информацию о загрузке мы будем получать напрямую от сервера.</li>
<li>Функция `trackStatus` будет открывать второй, параллельный, запрос `xhrStatus` и в нём, через `onprogress`, получать данные с сервера.</li>
</ul>

Серверный код будет читать из `xhrUpload`, записывать данные на диск и тут же рапортовать об этом в `xhrStatus`. 

Код соответствующей функции `upload`:

```js
//+ src="browser.js"
```

Детали `trackStatus`:
<ul>
<li>В ответ на запрос `xhrStatus` сервер присылает информацию о загрузке с данным идентификатором, дописывая в ответ при поступлении (и, если угодно, записи) очередного пакета -- общий размер загруженных данных.

Ответ сервера выглядит так:

```
1234-56789-123456-200123-423456-...
```

Это означает, что сервер сначала считал `1234` байта, затем получил ещё пакет и стало `56789`..И на текущий момент можно быть уверенными, что `423456` байт загружены.
</li>
<li>Функция `getLastProgress` читает из текущего ответа сервера последнее число. Обратим внимание, что она не может найти последний `-` и взять всё, что после него, т.к. последнее число, возможно, недогружено.

Поэтому из ответа выше она возьмёт `200123`.</li>
<li>Загрузка считается завершённой только после получения `xhrStatus.onload`.</li>
</ul>

Важна тонкость здесь -- в том, что запросы независимы. Любой из них может прийти на сервер первым. Возможно и такое, что закачка завершится до того, как запрос на статус достигнет сервера.

### Демо

Пример вместе с кодом сервера на NodeJS: 

[iframe src="upload-2way" link zip border="1" height="160"]

К этому коду можно легко добавить любую логику возобновления загрузки, подсчёта контрольной суммы и т.п. Ведь мы всегда точно знаем, до какого момента сервер получил файл.

## Способ 3: загружаем по частям

Есть ещё один способ. Я привожу его здесь для полноты, так как не раз видел его в статьях в интернет.

Он заключается в том, чтобы разбить файл на части и отсылать их одну за другой. 

Примерно так:

```js
function upload() {
  // каждая часть 64000 байт, 
  // можно делать меньше для маленьких файлов и больше для быстрых соединений
  var chunk = file.slice(startByte, startByte+64000);
 
  // на текущий момент уже загрузили from байт
  onProgress(from, file.size); 

  var xhr = new XMLHttpRequest();
  
  xhr.onload = function() {
    // если всё закачали или сервер ответил ошибку - завершение
    // если нет - вызвать загрузку следующей части
    upload(file, startByte + 64000);
  };

  xhr.onerror = function() {
    setTimeout(upload, 1000);
  };

  // ...
  xhr.send(chunk);
}
```

Пример заголовков и алгоритма для возобновляемой загрузки: [Спецификация Nginx Upload](http://www.grid.net.ru/nginx/resumable_uploads.ru.html). По ней работает модуль [Nginx Upload Module](http://www.grid.net.ru/nginx/upload.ru.html), но он, к сожалению, нестабилен, на момент написания этих строк замечены падения сервера, да и автор не горит желанием исправлять ошибки и отвечать на вопросы.

Если вы вдруг видите преимущество этого способа перед описанными выше -- напишите об этом в комментариях.

## Итого

Мы рассмотрели 3 способа загрузки файлов через `XMLHttpRequest`:

<ul>
<li>Простой способ, с неточной индикацией прогресса.</li>
<li>Более сложный способ, с увеличенным трафиком, но точной индикацией прогресса.</li>
<li>Загрузка по частям.</li>
</ul>

Все их можно расширить каким угодно образом, включая:
<ul>
<li>Параллельную загрузку одного файла в несколько потоков.</li>
<li>Хранение состояния в `localStorage`.</li>
<li>Подсчёт контрольной суммы при загрузке. Для быстрой проверки рекомендуется алгоритм Adler32 (это быстрый вариант CRC-32 для длинных строк), для безопасной -- MD5, и то и другое реализуется на JavaScript.</li>
</ul>
