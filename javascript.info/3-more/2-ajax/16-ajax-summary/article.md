# Таблица транспортов и их возможностей 

Здесь мы подведём итог раздела, сравним транспорты и их возможности.
[cut]

## Способы опроса сервера

Основные способы опроса сервера:
<ol>
<li>**Частые опросы** -- регулярно к серверу отправляется запрос за данными. Сервер тут же отвечает на него, возвращая данные, если они есть. Если нет -- получается, что запрос был зря.

Этот способ очень лёгок в реализации, но приводит к большому количеству лишних запросов, поэтому мы его далее не рассматриваем.
</li>
<li>**Длинные опросы** -- к серверу отправляется запрос за данными. Сервер не отвечает на него, пока данные не появятся. Когда данные появились -- ответ с ними отправляется в браузер, и тот тут же делает новый запрос.

Способ хорош, пока сообщений не слишком много. В идеальном случае соединение почти всё время висит открытым, лишь иногда сервер отвечает на него, доставляя данные в браузер.

Также удобен в реализации, но даёт большое количество висящий соединений на сервере. Не все сервера хорошо поддерживают это. Например, `Apache` будет есть очень много памяти.
</li>
<li>**Потоковое соединение** -- открыто соединение к серверу, и через него непрерывно поступают данные.</li>
</ol>

## Таблица транспортов
Основные характеристики всех транспортов, которые мы обсуждали в деталях, собраны в этой таблице.

Они были детально рассмотрены в предыдущих главах раздела.

<table>
<tr>
<th></th>
<th>`XMLHttpRequest`</th>
<th>`IFRAME`</th>
<th>`SCRIPT`</th>
<th>`EventSource`</th>
<th>`WebSocket`</th>
</tr>
<tr>
<th>Кросс-доменность</th>
<td>да, кроме IE9-<a class="link-ref" href="#x1">x1</a></td>
<td>да, сложности в IE7-<a class="link-ref" href="#i1">i1</a></td>
<td>да</td>
<td>да</td>
<td>да</td>
</tr>
<tr>
<th>Методы</th>
<td>Любые</td>
<td>GET / POST</td>
<td>GET</td>
<td>GET</td>
<td>Свой протокол</td>
</tr>
<tr>
<th>COMET</th>
<td>Длинные опросы<a class="link-ref" href="#x2">x2</a></td>
<td>Непрерывное соединение</td>
<td>Длинные опросы</td>
<td>Непрерывное соединение</td>
<td>Непрерывное соединение в обе стороны</td>
</tr>
<tr>
<th>Поддержка</th>
<td>Все браузеры, ограничения в IE&lt;10<a class="link-ref" href="#x3">x3</a></td>
<td>Все браузеры</td>
<td>Все браузеры</td>
<td>Кроме IE</td>
<td>IE 10, FF11, Chrome 16, Safari 6, Opera 12.5<a class="link-ref" href="#w1">w1</a></td>
</tr>
</table>

Пояснения:

<dl>
<dt>`XMLHttpRequest`</dt>
<dd>
<ol>
<li id="x1">В IE8-9 поддерживаются кросс-доменные GET/POST запросы с ограничениями через `XDomainRequest`.</li>
<li id="x2">Можно говорить об ограниченной поддержке непрерывного соединения через `onprogress`, но это событие вызывается не чаще чем в `50ms` и не гарантирует получение полного пакета данных. Например, сервер может записать "Привет!", а событие вызовется один раз, когда браузер получил "При". Поэтому наладить обмен пакетами сообщений с его помощью затруднительно.
</li>
<li id="x3">Многие возможности современного стандарта включены в IE лишь с версии 10.</li>
</ol>
</dd>
<dt>`IFRAME`</dt>
<dd>
<ol>
<li id="i1">Во всех современных браузерах и IE8 кросс-доменность обеспечивает `postMessage`. В более старых браузерах возможны решения через `window.name` и `hash`.</li>
</ol>
</dd>
<dt>`WebSocket`</dt>
<dd>
<ol>
<li id="w1">Имеется в виду поддержка окончательной редакции протокола [RFC 6455](http://tools.ietf.org/html/rfc6455). Более старые браузеры могут поддерживать черновики протокола. IE9- не поддерживает `WebSocket`.</li>
</ol>
</dd>
</dl>

Существует также транспорт, не рассмотренный здесь:
<ul>
<li>XMLHttpRequest с флагом `multipart`, только для Firefox. 

При указании свойства `xhr.multipart = true` и специального multipart-формата ответа сервера, Firefox инициирует `onload` при получении очередной части ответа.

Ответ может состоять из любого количества частей, досылаемых по инициативе сервера.
</li>
</ul>
Мы не рассматривали его, т.к. Firefox поддерживает и другие, стандартные, транспорты.



 
[head]
<script src="/files/tutorial/ajax/script/scriptRequest.js"></script>
[/head]