# XMLHttpRequest: кросс-доменные запросы

Обычно запрос `XMLHttpRequest` может делать запрос только в рамках текущего сайта. При попытке использовать другой домен/порт/протокол -- браузер выдаёт ошибку.

Существует современный стандарт [XMLHttpRequest](http://www.w3.org/TR/XMLHttpRequest/), он ещё в состоянии черновика, но предусматривает кросс-доменные запросы и многое другое.

[cut]

Большинство возможностей этого стандарта уже поддерживаются всеми браузерами, но увы, не в IE9-. 

Впрочем, частично кросс-доменные запросы поддерживаются, начиная с IE8, только вместо `XMLHttpRequest` нужно использовать объект [XDomainRequest](http://msdn.microsoft.com/en-us/library/ie/cc288060.aspx). 

## Кросс-доменные запросы  [#cors]

Разберём кросс-доменные запросы на примере кода:

```js
// (1)
var xhr = new XMLHttpRequest();
if (!xhr.onload) { // это IE 8/9, в них старый XMLHttpRequest
  if (!window.XDomainRequest) throw new Error("Not supported");
  xhr = new XDomainRequest(); // ..но есть XDomainRequest
}

// (2) запрос на другой домен :)
xhr.open('GET', 'http://anywhere.com/vote.php', true);

// (3)
xhr.onload = function() {
  alert(this.responseText);
}

xhr.onerror = function() {
  alert('Ошибка ' + this.status);
}

xhr.send('');
```

Комментарии:
<ol>
<li>Мы создаём `XMLHttpRequest` и проверяем, поддерживает ли он событие `onload`. Если нет, то это старый `XMLHttpRequest`. Возможно, у нас IE8-9, значит надо попробовать `XDomainRequest`.</li>
<li>Запрос на другой домен отсылается просто указанием соответствующего URL в `open`. Он должен быть асинхронным.</li>
<li>Все браузеры, которые поддерживают кросс-доменные запросы, поддерживают и события `onload/onerror`, которые можно использовать вместо `onreadystatechange`.</li>
</ol>



### Контроль безопасности

Контроль безопасности осуществляется на уровне браузера. 

**В кросс-доменный запрос браузер автоматически добавляет заголовок `Origin`, содержащий домен, с которого осуществлён запрос.**

В данном случае заголовки будут примерно такие:

```
GET /vote.php
Accept:*/*
Accept-Charset:windows-1251,utf-8;q=0.7,*;q=0.3
Accept-Encoding:gzip,deflate,sdch
Accept-Language:ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4
Connection:keep-alive
Host:anywhere.com
*!*
Origin:http://javascript.ru
*/!*
```

Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли он такой запрос к себе.


**Если сервер разрешает кросс-доменный запрос с этого домена -- он должен добавить к ответу заголовок `Access-Control-Allow-Origin`, содержащий домен запроса или  звёздочку `*`.** 

Только при наличии такого заголовка в ответе -- браузер сочтёт запрос успешным, а иначе JavaScript получит ошибку.

То есть, ответ сервера может быть примерно таким:

```
HTTP/1.1 200 OK
Content-Type:text/html; charset=UTF-8
*!*
Access-Control-Allow-Origin: http://javascript.ru
*/!*
```

**Описанный выше поток выполнения обладает двумя особенностями:**

<ol>
<li>Не передаются куки и заголовки HTTP-авторизации. Параметры `user` и `password` в методе `open` игнорируются. </li>
<li>Речь пока только о GET и POST-запросах, другие методы обрабатываются по-другому.</li>
</ol>

[warn header="Что может сделать хакер, используя такие запросы?"]
Описанные выше ограничения приводят к тому, что запрос полностью безопасен.

Действительно, нехороший человек со злой страницы может сформировать любой GET/POST-запрос и отправить его, но без разрешения сервера ответа он не получит.

А без ответа такой запрос, по сути, эквивалентен отправке формы GET/POST, причём  без авторизации.
[/warn] 






### Ограничения IE9-

В IE9- используется `XDomainRequest`, который представляет собой урезанный `XMLHttpRequest`. 

На него действуют ограничения:

<ul>
<li>Протокол нужно сохранять: запросы допустимы с HTTP на HTTP, с HTTPS на HTTPS. Другие протоколы запрещены.</li>
<li>Метод `open(method, url)` имеет только два параметра. Он всегда асинхронный.</li>
<li>Ряд возможностей современного стандарта недоступны, в частности:
<ul><li>Недоступны методы, кроме GET или POST.</li>
<li>Нельзя добавлять свои заголовки, даже нельзя указать свой `Content-Type` для запроса, он всегда `text/plain`.</li>
<li>Нельзя включить передачу кук и данных HTTP-авторизации.</li>
</ul>
</li>
<li>В IE8 в режиме просмотра InPrivate кросс-доменные запросы не работают.</li>
</ul>

Современный стандарт [XMLHttpRequest](http://www.w3.org/TR/XMLHttpRequest/) предусматривает средства для преодоления этих ограничений, но на момент выхода IE8 они ещё не были проработаны, поэтому их не реализовали. А IE9 исправил некоторые ошибки, но в общем не добавил ничего нового.

Так как большинство сайтов хотят поддерживать IE9-, то на практике кросс-доменные запросы редко используют, предпочитая другие способы кросс-доменной коммуникации. Например, динамически создаваемый тег `SCRIPT` или вспомогательный `IFRAME` с другого домена. Мы разберём эти подходы в последующих главах.

[smart header="Как разрешить кросс-доменные запросы от доверенного сайта в IE9-?"]

Разрешить кросс-доменные запросы можно в настройках IE, во вкладке "Безопасность", включив пункт "Доступ к источникам данных за пределами домена".

Обычно это делается не для всех сайтов, а для зоны "Надёжные узлы", после чего в неё вносится доверенный сайт. Теперь он может делать кросс-доменные запросы `XMLHttpRequest`.

Этот способ можно применить для корпоративных сайтов, а также в тех случаях, когда посетитель заведомо вам доверяет, но почему-то (компьютер на работе, админ запрещает ставить другой браузер?) хочет использовать именно IE. Например, он может предлагаться в качестве дополнительной инструкции "как заставить этот сервис работать под IE".
[/smart]

[smart header="В IE разрешён другой порт"]
В кросс-доменные ограничения IE не включён порт. 

То есть, можно сделать запрос с `http://javascript.ru` на `http://javascript.ru:8080`, и в IE он не будет считаться кросс-доменным.

Это позволяет решить некоторые задачи, связанные с взаимодействием различных сервисов в рамках одного сайта.

[/smart]

Есть и другие способы обойти кросс-доменные ограничения, например использование тега `SCRIPT` или `IFRAME`. Их детали мы рассмотрим в следующих главах, так как здесь мы рассматриваем именно `XMLHttpRequest`.


**Расширенные возможности, описанные далее, поддерживаются всеми современными браузерами, кроме IE9-.**

## Запросы от имени пользователя

Чтобы браузер передал вместе с запросом куки и, при необходимости, HTTP-авторизацию, поставьте запросу `xhr.withCredentials = true`:

```js
var xhr = new XMLHttpRequest(); // XDomainRequest не поддерживает это
xhr.withCredentials = true;

...
```

Далее -- всё как обычно, дополнительных действий со стороны клиента не требуется.

### Защита от CSRF

Кросс-доменный `XMLHttpRequest` с куками, безусловно, опаснее, чем анонимный. 

Представьте себе -- человек нечаянно попадает на страницу злого хакера. А она, используя JavaScript, отправляет кросс-доменный запрос на почтовый сервер, например GMail. 

Если с запросом отправятся куки, то получится, что этот запрос выполнился "от имени посетителя".

Подобные атаки давно существуют в интернете и называются [CSRF-атака](http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%BC%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D1%8B%D1%85_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2). Обычно они выполняются при помощи динамической генерации о отправки POST-формы. "Злая" страница может создать произвольную форму и отправить её на почтовый сервер. При этом с формой передадутся куки, то есть авторизация посетителя. Если почтовый сервер полагается только на них, то он выполнит запрошенное действие от имени пользователя.

**Чтобы защититься от CSRF-атак, почтовый сервер при генерации формы отправки сообщения добавляет в неё специальный ключ:**

```html
<form action="send.php" method="POST">
*!*
  <input type="hidden" name="csrf-token" value="abcdefabcdef">
*/!*
  ...
</form>
```

Этот ключ генерируется случайным образом и привязывается к сессии посетителя. Если посетитель честно открыл браузер и отправил форму со страницы, то в ней будет этот ключ. А "злая" страница этот ключ не знает, ведь его сгенерировал сервер. Даже открыв страницу с почтового сервера в `IFRAME`, она не сможет получить информацию со страницы -- `IFRAME`-то на другом домене.

...А без ключа она не сможет отправить сообщение. Сервер ведь его проверяет. Правильный ключ доказывает, что форма отправлена именно со страницы почтового сервера. 

В случае с кросс-доменным `XMLHttpRequest` ситуация принципиально меняется и атака становится куда опаснее!

Если сервер разрешает делать к себе `XMLHttpRequest` с `withCredentials`, то эту защиту легко обойти! Ведь `XMLHttpRequest` не просто делает запрос, а возвращает ответ, к которому JavaScript, (в отличие от результата отправки формы на другой домен) имеет полный доступ.

Например, "злая" страница может запросить страницу с формой отправки, найти в `responseText` нужный `<input name="csrf-token">` -- и вуаля, ключ есть, можно делать новый запрос, уже с гарантией прохождения.

**Поэтому для запросов с `withCredentials` предусмотрено дополнительное подтверждение со стороны сервера.**

Он должен показать, что разрешает делать не просто запросы, а запросы от имени посетителя. Как мы видим, это очень серьёзное разрешение.

**При запросе с `withCredentials` сервер должен вернуть уже не один, а два заголовка: `Access-Control-Allow-Origin: домен` и `Access-Control-Allow-Credentials: true`.**

Пример заголовков:

```js
HTTP/1.1 200 OK
Content-Type:text/html; charset=UTF-8
*!*
Access-Control-Allow-Origin: http://javascript.ru
Access-Control-Allow-Credentials: true
*/!*
```

Использование звёздочки `*` в `Access-Control-Allow-Origin` при этом запрещено.

Если заголовков не будет, то браузер не даст JavaScript'у доступ к ответу сервера. И получится, что запрос -- не опаснее обычной CSRF-атаки.

## Чтение заголовков

Чтобы клиент мог прочитать HTTP-заголовок, сервер должен указать его имя в `Access-Control-Expose-Headers`.

Например:

```
HTTP/1.1 200 OK
Content-Type:text/html; charset=UTF-8
*!*
X-Uid: 123
X-Authorization: abcdefabcdef
Access-Control-Allow-Origin: http://javascript.ru
Access-Control-Expose-Headers: X-Uid, X-Authentication
*/!*
```

Это ограничение относится ко всем заголовкам, кроме "простых":

```
Cache-Control
Content-Language
Content-Type
Expires
Last-Modified
Pragma
```

**...То есть, `Content-Type` получить всегда можно, а доступ к специфическим заголовкам нужно открывать явно.**

## Нестандартные методы и заголовки

В кросс-доменном `XMLHttpRequest` можно указать не только `GET/POST`, но и любой другой метод, например `PUT`, `DELETE`.

Когда-то никто и не думал, что страница сможет сделать такие запросы. Поэтому ряд веб-сервисов написаны в предположении, что "если метод -- нестандартный, то это не браузер". Некоторые веб-сервисы даже учитывают это при проверке прав доступа. 

**Чтобы пресечь любые недопонимания, браузер использует предзапрос в случаях:**

<ul>
<li>Если метод -- не GET и не POST</li>
<li>Если метод -- POST, но заголовок `Content-Type` имеет значение отличное от `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`, например `application/xml`.</li>
<li>Если устанавливаются другие HTTP-заголовки</li>
</ul>

...Любое из условий выше ведёт к тому, что браузер cделает два HTTP-запроса.

Первый запрос называется "предзапрос" (английский термин "preflight"), он использует метод `OPTIONS`. Его задача -- спросить сервер, разрешает ли он использовать выбранный метод и заголовки.

Название метода браузер передаёт в `Access-Control-Request-Method`, а если в `XMLHttpRequest` добавлены особые заголовки, то и их тоже -- в `Access-Control-Request-Headers`.

### Пример запроса COPY

Рассмотрим запрос `COPY`, который используется в протоколе[WebDAV](http://www.webdav.org/specs/rfc2518.html) для управления файлами через HTTP:

```js
var xhr = new XMLHttpRequest();

xhr.open('COPY', 'http://site.com/~ilya', true);
xhr.setRequestHeader('Destination', 'http://site.com/~ilya.bak');

xhr.onload = ...
xhr.onerror = ...

xhr.send('...');
```

Браузер сначала шлёт предзапрос `OPTIONS`:

```
OPTIONS /~ilya HTTP/1.1
Host: site.com
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Encoding: gzip,deflate
Connection: keep-alive
*!*
Origin: http://javascript.ru
Access-Control-Request-Method: COPY
Access-Control-Request-Headers: Destination
*/!*
```

На этот запрос сервер должен ответить статусом 200, указав заголовки `Access-Control-Allow-Method: метод` и, если есть заголовки, `Access-Control-Allow-Headers: разрешённые заголовки`.

Дополнительно он может указать `Access-Control-Max-Age: sec`, где `sec` -- количество секунд, на которые нужно закэшировать разрешение. Тогда при последующих вызовах метода браузер уже не будет делать предзапрос.

В протоколе WebDav разрешены многие методы и заголовки, которые и перечислим в ответе:

```
HTTP/1.1 200 OK
Content-Type: text/plain
*!*Access-Control-Allow-Methods:*/!* PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK, PUT, GETLIB, VERSION-CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, REPORT, UPDATE, CANCELUPLOAD, HEAD, OPTIONS, GET, POST
*!*Access-Control-Allow-Headers:*/!* Overwrite, Destination, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, If-Modified-Since, X-File-Name, Cache-Control
*!*Access-Control-Max-Age:*/!* 86400
```

Браузер видит, что метод `COPY` -- в числе разрешённых и заголовок `Destination` -- тоже, и дальше он шлёт уже основной запрос.

При этом ответ на предзапрос он закэширует на 86400 сек (ровно сутки), так что следующие вызовы `COPY` сразу отправят основной запрос.

Основной запрос браузера:

```
COPY /~ilya HTTP/1.1
Host: site.com
Content-Type: text/html; charset=UTF-8
*!*
Destination: http://site.com/~ilya.bak
Origin: http://javascript.ru
*/!*
```

Ответ сервера, согласно спецификации [WebDav COPY](http://www.webdav.org/specs/rfc2518.html#rfc.section.8.8.8):

```
HTTP/1.1 207 Multi-Status
Content-Type: text/xml; charset="utf-8"
Content-Length: ...
*!*
Access-Control-Allow-Origin: http://javascript.ru
*/!*

<?xml version="1.0" encoding="utf-8" ?>
<d:multistatus xmlns:d="DAV:">
  ...
</d:multistatus>
```

Таким образом, через `XMLHttpRequest` можно удобно использовать любые методы и заголовки, главное чтобы сервер это разрешал.