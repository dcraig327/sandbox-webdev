# Обратные ссылки \\n и $n

На скобочные группы можно ссылаться как в самом паттерне, так и в строке замены.
[cut]

Ссылки в строке замены мы уже видели: они имеют вид `$n`, где `n` -- это номер скобочной группы. Вместо `$n` подставляется содержимое соответствующей скобки:

```js
//+ run
var name = "Александр Пушкин";

name = name.replace(/([а-яё]+) ([а-яё]+)/i, "$2, $1");
alert( name ); // Пушкин, Александр
```

К скобочной группе можно также обратиться в самом шаблоне.

Рассмотрим это в реальном примере -- необходимо найти строку в кавычках. Эта строка может быть в одинарных кавычках <code class="subject">'...'</code> или в двойных <code class="subject">"..."</code> -- не важно, в каких именно, но открывающая и закрывающая кавычки должны быть одинаковыми.

Как такие строки искать? Регэксп <code class="pattern">`['"](.*?)['"]`</code> позволяет использовать разные кавычки, но он даст неверный ответ в случае, если одна кавычка ненароком оказалась внутри другой, как например в строке <code class="subject">"She's the one"</code>:

```js
//+ run
str = "He said:\"She's the one\"."

reg = /['"](.*?)['"]/g

alert(str.match(reg)) // "She'
```

Как видно, регэксп нашёл открывающую кавычку <code class="match">"</code>, затем текст, вплоть до новой кавычки <code class="match">'</code>, которая закрывает соответствие.

Для того, чтобы попросить регэксп искать закрывающую кавычку -- такую же, как открывающую, мы обернём её в скобочную группу и используем обратную ссылку на неё:

```js
//+ run
str = "He said:\"She's the one\"."

reg = /(['"])(.*?)\1/g

alert(str.match(reg)) // "She's the one"
```

Теперь работает верно!

Обратим внимание на два нюанса:

<ul>
<li>В строке замены ссылка на первую скобочную группу выглядит как `$1`, а в шаблоне нужно использовать `\1`.</li>
<li>Чтобы обращаться к скобочной группе -- не важно откуда, она не должна быть исключена из запоминаемых при помощи `?:`, то есть `(?:['"])` не подошло бы.</li>
</ul>
 
