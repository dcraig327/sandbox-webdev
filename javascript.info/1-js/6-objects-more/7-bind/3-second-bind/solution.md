Ответ: `"Вася"`.

```js
//+ run
function f() {
  alert(this.name);
}

f = f.bind( {name: "Вася"} ).bind( {name: "Петя"} );

f(); // Вася
```

Первый вызов `f.bind(..Вася..)` возвращает "обёртку", которая устанавливает контекст для `f` и передаёт вызов `f`.

Следующий вызов `bind` будет устанавливать контекст уже для этой обёртки, это ни на что не влияет.  

Чтобы это проще понять, используем наш собственный вариант `bind` вместо встроенного:

```js
function bind(func, context) {
  return function() { 
    return func.apply(context, arguments); 
  };
}
```

Код станет таким:

```js
function f() {
  alert(this.name);
}

f = bind(f, {name: "Вася"} ); // (1)
f = bind(f, {name: "Петя"} ); // (2)

f(); // Вася
```

Здесь видно, что первый вызов `bind`, в строке `(1)`, возвращает обёртку вокруг `f`, которая выглядит так (выделена):

```js
function bind(func, context) {
*!*
  return function() { 
    return func.apply(context, arguments); 
  };
*/!*
}
```

В этой обёртке нигде не используется `this`, только `func` и `context`. Посмотрите на код, там нигде нет `this`.

Поэтому следующий `bind` в строке `(2)`, который выполняется уже над обёрткой и фиксирует в ней `this`, ни на что не влияет. Какая разница, что будет в качестве `this` в функции, которая этот `this` не использует?
