# Проверка класса: "instanceof" 

Оператор `instanceof` позволяет проверить, какому классу принадлежит объект, с учетом прототипного наследования.

[cut]

## Алгоритм работы instanceof [#ref-instanceof]

Вызов `obj instanceof Constructor` возвращает `true`, если объект принадлежит классу `Constructor` или его родителям.

Пример использования:

```js
//+ run
function Rabbit() { }

*!*
// создаём объект
*/!*
var rabbit = new Rabbit();

// проверяем -- этот объект создан Rabbit?
*!*
alert(rabbit instanceof Rabbit); // true, верно
*/!*
```

Массив `arr` принадлежит классу `Array`, но также и является объектом `Object`. Это верно, так как массивы наследуют от объектов:

```js
//+ run
var arr = [];
alert(arr instanceof Array); // true
alert(arr instanceof Object); // true
```

Как это часто бывает в JavaScript, здесь есть ряд тонкостей. В некоторых ситуациях, проверка может даже ошибаться!

**Алгоритм проверки `obj instanceof Constructor`:**

<ol>
<li>Получить `obj.__proto__`</li>
<li>Сравнить `obj.__proto__` с `Constructor.prototype`</li>
<li>Если не совпадает, тогда заменить `obj` на `obj.__proto__` и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат `true`), либо цепочка прототипов не закончится (результат `false`).</li>
</ol>

В проверке `rabbit instanceof Rabbit`, совпадение на первом же шаге этго алгоритма, так как: `rabbit.__proto__ == Rabbit.prototype`.

А если рассмотреть `arr instanceof Object`, то совпадение будет найдено на следующем шаге, так как `arr.__proto__.__proto__ == Object.prototype`.

Забавно, что сама функция-констуктор не участвует в процессе проверки! Важна только цепочка прототипов для проверяемого объекта.

Это может приводить к забавному результату и даже ошибкам в проверке при изменении `prototype`, например:

```js
//+ run
// Создаём объект rabbit, как обычно
function Rabbit() { }
var rabbit = new Rabbit();

// изменили prototype...
Rabbit.prototype = {};

// ...instanceof перестал работать!
*!*
alert( rabbit instanceof Rabbit ); // false
*/!*
```

Стоит ли говорить, что это один из доводов для того, чтобы никогда не менять `prototype`? Так сказать, во избежание.

[warn header="Не друзья: `instanceof` и фреймы"]

Оператор `instanceof` не срабатывает, когда значение приходит из другого окна или фрейма.

Например, массив, который создан в ифрейме и передан родительскому окну -- будет массивом *в том ифрейме*, но не в родительском окне. Проверка `instanceof Array` в родительском окне вернёт `false`.

Вообще, у каждого окна и фрейма -- своя иерархия объектов и свой `window` .

Как правило, эта проблема возникает со встроенными объектами, в этом случае используется проверка внутреннего свойства `[[Class]]`. Более подробно это описано в главе [](/class-property).
[/warn]


## instanceof + наследование + try..catch = ♡

Когда мы работаем с внешними данными, возможны самые разные ошибки. 

Создание иерархии ошибок вносит порядок в происходящее, а `instanceof` внутри `try..catch` позволяет легко понять, что за ошибка произошла и обработать, либо пробросить её дальше.

Для примера создадим функцию `readUser(json)`, которая будет разбирать JSON с данными посетителя. Мы его получаем с сервера -- может, нашего, а может -- чужого, в общем -- желательно проверить на ошибки. А может, это даже и не JSON, а какие-то другие данные -- не важно, для наглядности поработаем с JSON.

Пример правильного JSON: `{ "name": "Вася", "age": 30 }`. 

Функция `readUser` должна бросать исключение в случаях, когда:

<ol>
<li>В JSON синтаксическая ошибка, то есть "падает" вызов `JSON.parse`.</li>
<li>В получившемся объекте нет свойства `name` или `age`.</li>
<li>Свойство `age` (возраст) -- не число.</li>
</ol>

Для каждого из этих типов ошибок сделаем отдельный класс -- это поможет позже легко идентифицировать произошедшее:

<ol>
<li>`SyntaxError` -- ошибка "что-то не так в данных", встроенный класс, ошибка такого типа генерируется как раз `JSON.parse`.</li>
<li>`PropertyRequiredError` -- ошибка "нет свойства", будет наследовать от `SyntaxError`,  так как является подвидом синтаксической ошибки.</li>
<li>`FormatError` -- "ошибка форматирования", тоже наследник `SyntaxError`.</li>
</ol>

Вот ошибки в JS:

```js
function PropertyRequiredError(property) {
*!*
  this.property = property;
  this.message = "Отсутствует свойство " + property;
*/!*
  this.name = 'PropertyRequired';
}      
PropertyRequiredError.prototype = Object.create(SyntaxError.prototype);


function FormatError(message) {
  this.message = message;
  this.name = 'FormatError';
}
FormatError.prototype = Object.create(SyntaxError.prototype);
```

Понятное дело, эти классы ошибок имеют общий характер и могут использоваться не только в данной конкретной функции, но и в других местах кода -- при обработке любых данных.
 
**У разных типов ошибок могут быть разные конструкторы, разные дополнительные свойства, которые позволят в дальнейшем удобно работать с ошибкой.**

В коде выше обратите внимание на `PropertyRequiredError` -- конструтор этой ошибки получает отсутствующее свойство и сохраняет его в дополнительном свойстве `property`, в дополнение к стандартному `message`. В дальнейшем, для особой обработки этой ошибки, его легко можно будет получить.

Код ниже -- полная реализация `readUser`:

```js
function PropertyRequiredError(property) {
  this.property = property;
  this.message = "Отсутствует свойство " + property;
  this.name = 'PropertyRequired';
}      
PropertyRequiredError.prototype = Object.create(SyntaxError.prototype);


function FormatError(message) {
  this.message = message;
  this.name = 'FormatError';
}
FormatError.prototype = Object.create(SyntaxError.prototype);


function readUser(data) {
  
  var user = JSON.parse(data);

  validateUser(user);

  return user;
}

function validateUser(user) {
  
  if (!user.age) {
    throw new PropertyRequiredError("age"); 
  }
  if (typeof user.age != "number") {
    throw new FormatError("Возраст - не число");
  }

  if (!user.name) {
    throw new PropertyRequiredError("name"); 
  }
  
}

try {
  readUser('{ "name": "Вася", "age": "unknown" }');
} catch (e) {
*!*
  if (e instanceof PropertyRequiredError) {
    if (e.property == 'name') {
      // в данном месте кода возможны анонимы, ошибка поправима
      user[e.property] = "Аноним";
    } else {
      alert(e.message); 
    }
  } else if (e instanceof SyntaxError) {
    alert("Ошибка в данных: " + e.message); 
  } else {
    throw e; // неизвестная ошибка, не знаю что с ней делать
  }      
*/!*
}
```

Обратим внимание -- в данном конкретном месте кода мы допускаем анонимных посетителей, поэтому в случае, если отсутствует `name` -- исправляем эту ошибку. Мы можем легко это сделать, благодаря наличию у `PropertyRequiredError` дополнительного (по сравнению со стандартными ошибками) свойства `property`.

**Для проверки, какая именно ошибка произошла, вместо `e.name` используется `instanceof`.**

Это позволяет как выделить какие-то отдельные типы ошибок (`e instanceof PropertyRequiredError`), так и проверить общий тип, с которым мы умеем работать, без оглядки на его детали (`e instanceof SyntaxError`).

Благодаря `instanceof` мы получили удобную поддержку иерархии ошибок, с возможностью в любой момент добавить новые классы, понятным кодом и предсказуемым поведением.

## Итого

<ul>
<li>Оператор `obj instanceof Func` проверяет тот факт, что `obj` является результатом вызова `new Func`. Он учитывает цепочку `__proto__`, поэтому наследование поддерживается.</li>
<li>Оператор `instanceof` не сможет проверить тип значения, если объект создан в одном окне/фрейме, а проверяется в другом. Это потому, что в каждом окне -- своя иерархия объектов. Для точной проверки типов встроенных объектов можно использовать свойство `[[Class]]`.</li>
<li>Оператор `instanceof` особенно востребован в случаях, когда мы работаем с иерархиями классов. Это наилучший способ проверить принадлежность тому или иному классу с учётом наследования.</li>
</ul>
