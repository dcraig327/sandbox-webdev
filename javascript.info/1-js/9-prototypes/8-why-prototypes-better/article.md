# Сравнение с функциональным наследованием

В этой главе мы озаботимся тем, чтобы сравнить прототипный и функциональный подход к ООП.

Причём, сделать это грамотно, с учётом того, что реально происходит "под капотом" интерпретатора.

Нас интересуют три показателя:
<ol>
<li>Эффективность по памяти.</li>
<li>Скорость работы.</li>
<li>Архитектурные ограничения (если есть) и плюшки.</li>
</ol>

[cut]

## Класс Machine

Объявим класс `Machine` двумя способами:
<dl>
<dt>Функциональное объявление:</dt>
<dd>Состоит из единственной функции-конструктора, которая записывает в объект всё, что нужно. Приватные данные сохраняются в локальные переменные и доступны через замыкание:

```js
function MachineOne(power) {
  var enabled = false;

  this.enable = function() {  enabled = true; };
  this.disable = function() { enabled = false; };
 
  // ...
}
```

При этом у каждого объекта будет своя копия методов `enable` и `disable`, которые создаются каждый раз заново.
</dd>
<dt>Прототипное объявление:</dt>
<dd>В объекте хранится только то, что ему нужно. Методы записываются в прототип:

```js
function MachineTwo(power) {
  this._enabled = false;
}

MachineTwo.prototype.enable = function() {  
  this._enabled = true; 
};

MachineTwo.prototype.disable = function() { 
  this._enabled = false; 
};
```

</dd>
</dl>

## Сравнение памяти

Оценим затраты памяти в функциональном стиле:

```js
var machine = new MachineOne();

затраты памяти = 
  сам объект + 
  свойства и методы в нём (this.enable/disable) + 
  замыкание, объект с приватными переменными (var enabled)
```

В этой, казалось бы, очевидной формуле кроется серьёзная ошибка. 

По коду кажется, каждый объект хранит свою копию методов `this.enable/disable`, однако это не совсем так.

Интерпретаторы оптимизируют создание и хранение одинаковых одинаковых функций. "Под капотом" *строка с кодом* функции `enable/disable` хранится только один раз, и её разделяют между собой все объекты `MachineOne`. То есть, если вывести функцию в виде строки `alert(machine.enable)`, то каждый объект возьмёт код из единого для всех места в памяти.

Далее, при использовании, строка с кодом на JavaScript превращается в *машинный код*, который может по-разному оптимизироваться, в зависимости от того, как именно используется функция, но и здесь интерпретатор старается разделять одинаково оптимизированный код между объектами. 

**То есть, на самом деле в каждом объекте хранится не полная копия метода, а скорее "метаданные", которые указывают, где в памяти лежит соответствующим образом оптимизированная функция.**

Теперь прототипный стиль:

```js
var machine = new MachineTwo();

затраты памяти = 
  сам объект + 
  свойства (this._enabled)
```

Если сравнить, то мы видим, что значение `var enabled` переместилось в сам объект, произошла небольшая экономия на объекте LexicalEnvironment, который больше не нужен. 

Кроме того, методы находятся в прототипе. Интерпретатор делает неплохую работу по оптимизации функционального стиля можно сказать, что "почти вся" информация о функциях будет разделяться между объектами, но в прототипном подходе функции разделяются на 100%, без "почти".

**Вывод: прототипный стиль требует меньше памяти, так как не хранится LexicalEnvironment и методы (совсем).**

В случае, когда объект хранит мало данных, и методы маленькие, разница в памяти может быть существенной. В браузере Chrome (V8) для описанных выше `MachineOne` и `MachineTwo` она может составлять 5-8 раз. Но это лишь потому, что объекты полностью синтетические, в них почти нет кода и данных. В реальности она меньше, порядка 1-3 раз, конечно это зависит от конкретного объекта.

## Сравнение производительности

Создание объекта в функциональном стиле дольше, поскольку происходят присвоения в `this`. Это очевидно.

Но может показаться, что при этом скорость доступа к таким методом "особо быстрая", так как они хранятся в самом объекте, а не в его прототипе.

Это не так.

"Под капотом" интерпретатор при первом вызове метода пробежится по цепочке `__proto__`, запомнит место, где его нашёл, и далее будет обращаться прямо туда.

**В современных браузерах скорость доступа к методам в прототипе и в объекте одинакова.**

Функциональный стиль и здесь не имеет преимущества.

## Красота синтаксиса

В функциональном стиле мы имеем красивые приватные переменные и функции. Это хорошо.

Но пользоваться публичными методами менее удобно.

Скажем, мы хотим при создании `new Machine` тут же включить машину вызовом `this.enable()`:

```js
function Machine(power) {
  var enabled = false;

  this.enable = function() {  enabled = true; };
  this.disable = function() { enabled = false; };
 
*!*
  // нужно писать этот вызов внизу
  this.enable();
*/!*
}
```

Мы вынуждены написать вызов `this.enable()` внизу, под определением соответствующего метода.

**Если методов много и они длинные, то получается, что при чтении кода нам нужно проматывать в конец файла. Это неудобно!**

Типичное средство обхода -- объявлять все методы через Function Declaration, а внизу выносить во внешний интерфейс нужные:

```js
function Machine(power) {
  var enabled = false;

  enable();

  function enable() {  enabled = true; };
  function disable() { enabled = false; };
 
*!*
  this.enable = enable;
  this.disable = disable;
*/!*
}
```

Ничего такого, но приходится писать лишние буквы, а у программиста и так нелёгкий труд.

Прототипное наследование похожей проблемы не имеет. Зато там нужно писать слово `prototype`, что, впрочем, исправляется различными ООП-фреймворками.

## Архитектурные ограничения 

Наследование, реализованное в функциональном стиле, обладает важным архитектурным ограничением.

**Конструктор наследника получает контроль лишь после полной инициализации родителя, и это может быть слишком поздно.**

Например, пусть конструктор `Machine` при инициализации вызывает свой метод `work()`. Это достаточно типично, что при создании объект тут же делает что-то полезное или заполняет себя важными данными. 

Потомок -- `CoffeeMachine` захочет переопределить этот метод. Реализация будет выглядеть так:

```js
//+ run
// Родитель:

function Machine() {
  this.work = function() {
    alert('Гр-р-р-р! Бям-бямс...');
  };

  this.work();
}

// Потомок:

function CoffeeMachine() {
  Machine.apply(this, arguments); 

*!* 
  // попытаемся переопределить метод в потомке
  this.work = function() {
    alert('Вжжжжжжжжж!');
  };
*/!*
}

// переопределение не сработало! 
*!*
var coffeeMachine = new CoffeeMachine(); // Гр-р-р-р! Бям-бямс...!
*/!*
```

Вызвался метод `work` не потомка, а родителя! 

Это естественно, ведь первым делом мы вызвали `Machine.apply(this, arguments)`, в котором используется старый `work`.

**Методы для инициализации, уже использованные родителем, переопределить в потомке нельзя: слишком поздно.**

Недостаток этот -- весьма серьёзный. Фактически, он ограничивает возможности построения архитектуры.

Заметим, что при использовании прототипов такой проблемы не возникает. Потому что сначала полностью задаются конструкторы, методы, задаётся порядок поиска через прототипы, а уже *потом* создаются объекты.

Аналогичный код через прототипы:

```js
//+ run
function Machine() {
  this.work();
}
Machine.prototype.work = function() {
  alert('Гр-р-р-р! Бям-бямс...');
};

function CoffeeMachine() {
  Machine.apply(this, arguments);
}
CoffeeMachine.prototype = Object.create(Machine.prototype);

CoffeeMachine.prototype.work = function() {
  alert('Вжжжжжжжжж!');
};

// переопределение сработает, work найден в CoffeeMachine.prototype 
*!*
var coffeeMachine = new CoffeeMachine(); // Вжжжжжжжжж!
*/!*
```

## Не учитывается наследование в instanceof

Есть и ещё одна проблема функционального подхода.

При наследовании в функциональном стиле проверка `coffeeMachine instanceof Machine` вернёт `false`.

Это вполне естественно, ведь, формально говоря, `CoffeeMachine` не является `Machine`.

Единственная связь между ними -- конструктор `CoffeeMachine` вызвал функцию `Machine` в своём контексте. Оператор `instanceof` работает через проверку цепочки прототипов, а здесь её нет.

**Здесь прототипный подход гораздо удобнее.**

Конечно, можно попробовать запоминать, кого и в каком порядке вызывали, разработать свой аналог `instanceof`, но обычно так не делают, т.к. в прототипах встроенный `instanceof` просто работает.

## Сжатие JavaScript

При функциональном наследовании используются локальные переменные и функции.

Современные средства сжатия JavaScript переименовывают их, делая короче и таким образом уменьшая размер кода. 

**Это означает, что код, написанный в функциональном стиле, сожмётся лучше.**

## Итого 

Получилось, что функциональный паттерн в сочетании с наследованием обладает рядом серьёзных проблем.

Его, по сути, основное достоинство -- это использование локальных функций и переменных, в которые никак нельзя залезть снаружи, и которые дают лучшее сжатие кода минификаторами.

Кроме того, если программировать без фреймворков, то функциональный стиль -- наиболее нагляден и прост.

Но если в проекте нужен единообразный стиль ООП, то лучше использовать прототипный подход, возможно прибавив "сахарку" в виде ООП-фреймворка (тысячи их), а функциональный использовать в тех случаях, когда *уже есть* сторонняя библиотека или конструкторы в этом стиле, которые нужно расширить.
