
# Генераторы [todo]

Генераторы -- новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.

## Создание генератора

Для объявления генератора используется новая синтаксическая конструкция: `function*` (функция со звёздочкой).

Её называют "функция-генератор" (generator function).

Выглядит это так:

```js
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
```

При запуске `generateSequence()` код такой функции не выполняется! 

Вместо этого она возвращает специальный объект, который как раз и называют "генератором". 

```js
// generator function создаёт generator
let generator = generateSequence();
```

Правильнее всего будет воспринимать генератор как "замороженный вызов функции":

<img src="generateSequence-1.png">

При создании генератора код находится в начале своего выполнения.

Основным методом генератора является `next()`. При вызове он возобновляет выполнение кода до ближайшего ключевого слова `yield`. По достижении `yield` выполнение приостанавливается, а значение -- возвращается во внешний код:

```js
//+ run
'use strict';

function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

let one = generator.next();

alert(JSON.stringify(one)); // {value: 1, done: false}
```

<img src="generateSequence-2.png">

Повторный вызов `generator.next()` возобновит выполнение и вернёт результат следующего `yield`:

```js
let two = generator.next();

alert(JSON.stringify(two)); // {value: 2, done: false}
```

<img src="generateSequence-3.png">

И, наконец, последний вызов завершит выполнение функции и вернёт результат `return`:

```js
let three = generator.next();

alert(JSON.stringify(three)); // {value: 3, *!*done: true*/!*}
```

<img src="generateSequence-4.png">


Функция завершена. Внешний код увидит это из свойства `done:true` и обработает `value:3`, как окончательный результат. Новые вызовы `generator.next()` больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: `{done: true}`.

"Открутить назад" завершившийся генератор нельзя, но можно создать новый ещё одним вызовом `generateSequence()` и выполнить его.

## Генератор -- итератор

Как вы, наверно, уже догадались по наличию метода `next()`, генератор является итерируемым объектом.

Его можно перебирать и через `for..of`:

```js
//+ run
'use strict';

function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, затем 2
}
```

Заметим, однако, существенную особенность такого перебора!

При запуске примера выше будет выведено значение `1`, затем `2`. Значение `3` выведено не будет. Это потому что стандартные перебор итератора игнорирует `value` на последнем значении, при `done: true`. Так что результат `return` в цикле `for..of` не выводится.

Соответственно, если мы хотим, чтобы все значения возвращались при переборе через `for..of`, то надо возвращать их через `yield`:


```js
//+ run
'use strict';

function* generateSequence() {
  yield 1;
  yield 2;
*!*
  yield 3;
*/!*
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, затем 2, затем 3
}
```

...А зачем вообще `return` при таком раскладе, если его результат игнорируется? Он тоже нужен, но в других ситуациях. Перебор через `for..of` -- в некотором смысле "исключение". Как мы увидим дальше, в других контекстах `return` очень даже востребован.

## Композиция генераторов

Один генератор может включать в себя другие. Это называется композицией. 

Разберём композицию на примере.

Пусть у нас есть функция `generateSequence`, которая генерирует последовательность чисел:

```js
//+ run
'use strict';

function* generateSequence(start, end) {

  for (let i = start; i <= end; i++) {
    yield i;
  }

}

// Используем оператор … для преобразования итерируемого объекта в массив
let sequence = [...generateSequence(2,5)];

alert(sequence); // 2, 3, 4, 5
```

Мы хотим на её основе сделать другую функцию `generateAlphaNumCodes()`, которая будет генерировать коды для буквенно-цифровых символов латинского алфавита:

<ul>
<li>`48..57` -- для `0..9`</li>
<li>`65..90` -- для `A..Z`</li>
<li>`97..122` -- для `a..z`</li>
</ul>

Далее этот набор кодов можно превратить в строку и использовать, к примеру, для выбора из него случайного пароля. Только символы пунктуации ещё хорошо бы добавить для надёжности, но в этом примере мы будем без них.

Естественно, раз в нашем распоряжении есть готовый генератор `generateSequence`, то хорошо бы его использовать.

Конечно, можно внутри `generateAlphaNum` запустить несколько раз `generateSequence`, объединить результаты и вернуть. Так мы бы сделали с обычными функциями. Но композиция -- это кое-что получше.

Она выглядит так:

```js
//+ run
'use strict';

function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {

*!*
  // 0..9
  yield* generateSequence(48, 57);

  // A..Z
  yield* generateSequence(65, 90);

  // a..z
  yield* generateSequence(97, 122);
*/!*

}

let str = '';

for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
```

Здесь использована специальная форма `yield*`. Она применима только к другому генератору и *делегирует* ему выполнение.

То есть, при `yield*` интерпретатор переходит внутрь генератора-аргумента, к примеру, `generateSequence(48, 57)`, выполняет его, и все `yield`, которые он делает, выходят из внешнего генератора.

Получается -- как будто мы вставили код внутреннего генератора во внешний напрямую, вот так:

```js
//+ run
'use strict';

function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {

*!*
  // yield* generateSequence(48, 57);
  for (let i = 48; i <= 57; i++) yield i;

  // yield* generateSequence(65, 90);
  for (let i = 65; i <= 90; i++) yield i;

  // yield* generateSequence(97, 122);
  for (let i = 97; i <= 122; i++) yield i;
*/!*

}

let str = '';

for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
```

Код выше по поведению полностью идентичен варианту с `yield*`.

Композиция -- это естественное встраивание одного генератора в поток другого. В частности, если поток данных из вложенного генератора оказался бесконечным (или ожидает какого-либо условия для завершения), то с точки зрения композиции это вполне нормально. 

## yield -- дорога в обе стороны

До этого генераторы наиболее напоминали "итераторы на стероидах". Но, как мы сейчас увидим, это не так, есть фундаментальное различие, генераторы гораздо мощнее и гибче.

Всё дело в том, что `yield` -- дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор. 

Вызов `let result = yield value` делает следующее:

<ul>
<li>Возвращает `value` во внешний код, приостанавливая выполнение генератора.</li>
<li>Внешний код может обработать значение, и затем вызвать `next` с аргументом: `generator.next(arg)`.</li>
<li>Генератор продолжит выполнение, аргумент `next` будет возвращён как результат `yield` (и записан в `result`).</li>
</ul>

Продемонстрируем это на примере:

```js
//+ run
'use strict';

function* gen() {
*!*
  // Передать вопрос во внешний код и подождать ответа
  let result = yield "Сколько будет 2 + 2?";
*/!*

  alert(result);
}

let generator = gen();

let question = generator.next().value; 
// "Сколько будет 2 + 2?"

setTimeout(() => generator.next(4), 2000);
```

На рисунке ниже прямоугольником изображён генератор, а вокруг него -- "внешний код", который с ним взаимодействует:

<img src="genYield2.png">

На этой иллюстрации показано то, что происходит в генераторе:

<ol>
<li>Первый вызов `generator.next()` -- всегда без аргумента, он начинает выполнение и возвращает результат первого `yield` ("Сколько будет 2+2?"). На этой точке генератор приостанавливает выполнение.</li>
<li>Результат `yield` переходит во внешний код (в `question`). Внешний код может выполнять любые асинхронные задачи, генератор стоит "на паузе".</li>
<li>Когда асинхронные задачи готовы, внешний код вызывает `generator.next(4)` с аргументом. Выполнение генератора возобновляется, а `4` выходит из присваивания как результат `let result = yield ...`.</li>
</ol>

В примере выше -- только два `next`. 

Возможно, происходящее будет проще понять, если их больше:

```js
//+ run
'use strict';

function* gen() {
  let ask1 = yield "Сколько будет 2 + 2?"; 

  alert(ask1); // 4

  let ask2 = yield "А сколько будет 3 * 3?"

  alert(ask2); // 9
}

let generator = gen();

alert( generator.next().value ); // "...2+2?"

alert( generator.next(4).value ); // "...3*3?"

alert( generator.next(9).done ); // true 
```

Взаимодействие с внешним кодом:

<img src="genYield2-2.png">

<ol>
<li>Первый `.next()` начинает выполнение... Оно доходит до первого `yield`.</li>
<li>Результат возвращается во внешний код.</li>
<li>Второй `.next(4)` передаёт `4` обратно в генератор как результат первого `yield` и возобновляет выполнение.</li>
<li>...Оно доходит до второго `yield`, который станет результатом `.next(4)`.</li>
<li>Третий `next(9)` передаёт `9` в генератор как результат второго `yield` и возобновляет выполнение, которое завершается окончанием функции, так что `done: true`.</li>
</ol>

Получается "пинг-понг": каждый `next(value)` передаёт в генератор значение, которое становится результатом текущего `yield`, возобновляет выполнение и получает выражение из следующего `yield`.

<img src="genYield2-3.png">

Исключением является первый вызов `next`, который не может передать значение в генератор, т.к. ещё не было ни одного `yield`.


## generator.throw

Как мы видели в примерах выше, внешний код может вернуть генератору в качестве результата `yield` любое значение.

...Но "вернуть" можно не только результат, но и ошибку!

Как и любая операция, `yield` может завершиться со значением, либо сгенерировать исключение. И то и то -- разновидность результата.

Для того, чтобы передать в `yield` ошибку, используется вызов `generator.throw(err)`. При этом на строке с `yield` возникает исключение.

Например, в коде ниже обращение к внешнему коду `yield "Сколько будет 2 + 2"` завершится с ошибкой:


```js
//+ run
'use strict';

function* gen() {
  try {
    // в этой строке возникнет ошибка
    let result = yield "Сколько будет 2 + 2?";

    alert("не сработает, так как ошибка выпадет в try..catch");
  } catch(e) {
    alert(e); // выведет ошибку
  } 
}

let generator = gen();

let question = generator.next().value;

*!*
generator.throw(new Error("ответ не найден в моей базе данных")); // (*)
*/!*
```

"Вброшенная" в строке `(*)` ошибка возникает в строке с `yield` и обрабатывается как обычно. В примере выше она перехватывается `try..catch` и выводится.

Если её не перехватить, то она "выпадет" из генератора. По стеку ближайший вызов, который инициировал выполнение -- это строка с `.throw`. Можно перехватить её там, как и продемонстрировано в примере ниже:


```js
//+ run
'use strict';

function* gen() {
  // В этой строке возникнет ошибка
  let result = yield "Сколько будет 2 + 2?";
}

let generator = gen();

let question = generator.next().value;

*!*
try {
  generator.throw(new Error("ответ не найден в моей базе данных")); 
} catch(e) {
  alert(e); // выведет ошибку
}
*/!*
```

Если же ошибка и там не перехвачена, то дальше -- как обычно, либо `try..catch` снаружи, либо она "повалит" скрипт.

# Плоский асинхронный код

Одна из основных областей применения генераторов -- написание "плоского" асинхронного кода.

Общий принцип такой:
<ul>
<li>Генератор `yield'ит` не просто значения, а промисы.</li>
<li>Есть специальная "функция-чернорабочий" `execute(generator)` которая запускает генератор, последовательными вызовами `next` получает из него промисы -- один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим `next`.</li>
<li>Последнее значение генератора (`done:true`) `execute` уже обрабатывает как окончательный результат -- например, возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.</li>
</ul>

Напишем такой код для получения аватара пользователя с github и его вывода, аналогичный рассмотренному в статье про [промисы](/promise).

Для AJAX-запросов будем использовать метод [fetch](/fetch), он как раз возвращает промисы.

```js
//+ run
'use strict';

// генератор для получения и показа аватара
function* showUserAvatar() {

  let userFetch = yield fetch('/article/generator/user.json');
  let userInfo = yield userFetch.json();

  let githubFetch = yield fetch(`https://api.github.com/users/${userInfo.name}`); 
  let githubUserInfo = yield githubFetch.json();

  let img = new Image();
  img.src = githubUserInfo.avatar_url;
  img.className = "promise-avatar-example";
  document.body.appendChild(img);

  yield new Promise(resolve => setTimeout(resolve, 3000));

  img.remove();

  return img.src;
}

// вспомогательная функция-чернорабочий для выполнения промисов
function execute(generator, yieldValue) {

  let next = generator.next(yieldValue);

  if (!next.done) {
    next.value.then(
      result => execute(generator, result),
      err => generator.throw(err)
    );
  } else {
    // return из генератора (обработаем результат)
    // обычно здесь вызов callback или что-то в этом духе
    alert(next.value); 
  }

}

*!*
execute( showUserAvatar() );
*/!*
```

Функция `execute` в примере выше -- универсальная, она может работать с любым генератором, который `yield'ит` промисы.

Вместе с тем, это -- всего лишь набросок, чтобы было понятно, как такая функция в принципе работает. Есть уже готовые реализации, обладающие большим количеством возможностей.

Одна из самых известных -- это библиотека [co](https://github.com/tj/co).

Её нужно подключить (через `npm` или https://cdnjs.cloudflare.com/ajax/libs/co/4.1.0/index.min.js), после чего запускаем её с функцией-генератором, вот так:

```js
//+ run

'use strict';

co(function*() {
  
  let result = yield new Promise(
    resolve => setTimeout(resolve, 1000, 1)
  );

  alert(result); // 1

})
```

Библиотека `co`, как и `executor` выше, выполняет генератор, получает из него промисы и возвращает обратно их результаты. В примере выше `function*()` делает `yield` промиса с `setTimeout`, который через секунду возвращает `1`.

Вызов `co(…)` возвращает промис с результатом генератора. Если в примере выше `function*()` что-то возвратит, то это можно будет получить через `.then` в результате `co`:

```js
//+ run
'use strict';

co(function*() {
  
  let result = yield new Promise(
    resolve => setTimeout(resolve, 1000, 1)
  );

*!*
  return result; // return 1

}).then(alert); // 1
*/!*
```
[warn header="Обязательно нужен `catch`"]

Частая ошибка начинающих -- вообще забывать про обработку результата `co`. Даже если результата нет, ошибки нужно обработать через `catch`, иначе они "подвиснут" в промисе.

Такой код ничего не выведет:

```js
//+ run
co(function*() {
  throw new Error("Sorry that happened");
})
```

Программист даже не узнает об ошибке. Особенно обидно, когда это опечатка или другая программная ошибка, которую обязательно нужно поправить.

Правильный вариант:

```js
//+ run
co(function*() {
  throw new Error("Sorry that happened");
}).catch(alert); // обработать ошибку как-либо
```

Большинство примеров этого `catch` не содержат, но это лишь потому, что в примерах ошибок нет. А в реальном коде обязательно нужен `catch`.

[/warn]

**Библиотека `co` может работать не только с генераторами.**

Есть несколько видов значений, которые умеет обрабатывать `co`:

<ul>
<li>Объект-генератор -- выполняется описанным выше способом.</li>
<li>Функция-генератор `function*()` -- `co` её выполнит, затем выполнит полученный генератор.</li>
<li>Промис -- `co` вернёт его (на самом деле новый промис, но он вернёт этот).</li>
<li>Функция с единственным аргументом вида `function(callback)` -- библиотека `co` её запустит со своей функцией-`callback` и будет ожидать, что при ошибке она вызовет `callback(err)`, а при успешном выполнении -- `callback(null, result)`, то есть в первом аргументе -- будет ошибка (если есть), а втором -- результат (если нет ошибки). После чего результат будет передан в генератор.</li>
<li>Массив или объект из вышеперечисленного. При этом все задачи будут выполнены параллельно, и результат, в той же структуре, будет выдан наружу.</li>
</ul>

В примере ниже происходит `yield` всех этих видов значений:

```js
//+ run
'use strict';

Object.defineProperty(window, 'result', { 
  // присвоение result=… будет выводить значение
  set: value => alert(JSON.stringify(value))
});

co(function*() {
  result = yield function*() { // генератор
    return 1;
  }();

  result = yield function*() { // функция-генератор
    return 2;
  };

  result = yield Promise.resolve(3); // промис

  result = yield function(callback) { // function(callback)
    callback(null, 4);
  };


  result = yield { // две задачи выполнит параллельно, как Promise.all
    one: Promise.resolve(1),
    two: function*() { return 2; }
  };

  result = yield [ // две задачи выполнит параллельно, как Promise.all
    Promise.resolve(1),
    function*() { return 2 }
  ];

});
```

**Библиотеку `co` можно использовать один раз в самом внешнем вызове.**

Библиотека `co` обрабатывает результаты рекурсивно. То есть, если в результате `yield` получается генератор, то ...

TODO


function* showUserAvatar() {

  let userFetch = yield fetch('/article/generator/user.json');
  let userInfo = yield userFetch.json();

  let githubFetch = yield fetch(`https://api.github.com/users/${userInfo.name}`); 
  let githubUserInfo = yield githubFetch.json();

  let img = new Image();
  img.src = githubUserInfo.avatar_url;
  img.className = "promise-avatar-example";
  document.body.appendChild(img);

  yield new Promise(resolve => setTimeout(resolve, 3000));

  img.remove();

  return img.src;
}


co(showUserAvatar)

[head]
<style>
.promise-avatar-example {
  border-radius: 50%;
  position: fixed;
  right: 0;
  top: 0;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/co/4.1.0/index.min.js"></script>
[/head]







