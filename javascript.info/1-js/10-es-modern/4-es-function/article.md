
# Функции

В функциях основные изменения касаются передачи параметров, плюс введена дополнительная короткая запись через стрелочку `=>`.

## Параметры по умолчанию

Можно указывать параметры по умолчанию через равенство `=`, например:

```js
//+ run
function showMenu(title = "Без заголовка", width = 100, height = 200) {
  alert(`${title} ${width} ${height}`);
}

showMenu("Меню"); // Меню 100 200
```

Параметр по умолчанию используется при отсутствующем аргументе или равном `undefined`, например:

```js
//+ run
function showMenu(title = "Заголовок", width = 100, height = 200) {
  alert(`title=${title} width=${width} height=${height}`);
}

// По умолчанию будут взяты 1 и 3 параметры
// title=Заголовок width=null height=200
showMenu(undefined, null); 
```

При передаче любого значения, кроме `undefined`, включая пустую строку, ноль или `null`, параметр считается переданным, и значение по умолчание не используется.

**Параметры по умолчанию могут быть не только значениями, но и выражениями.**

Например:

```js
//+ run
function sayHi(who = getCurrentUser().toUpperCase()) {
  alert(`Привет, ${who}!`);
}

function getCurrentUser() {
  return 'Вася';
}

sayHi(); // Привет, ВАСЯ!
```

Заметим, что значение выражения `getCurrentUser().toUpperCase()` будет вычислено, и соответствующие функции вызваны -- лишь в том случае, если это необходимо, то есть когда функция вызвана без параметра.

В частности, выражение по умолчанию не вычисляется при объявлении функции. В примере выше функция `getCurrentUser()` будет вызвана именно в последней строке, так как не передан параметр.


## Оператор spread вместо arguments

Чтобы получить массив аргументов, можно использовать оператор `…`, например:

```js
//+ run

function showName(firstName, lastName, *!*...rest*/!*) {
  alert(`${firstName} ${lastName} - ${rest}`);
}

// выведет: Юлий Цезарь - Император,Рима
showName("Юлий", "Цезарь", "Император", "Рима");
```

В `rest` попадёт массив всех аргументов, начиная со второго.

Заметим, что `rest` -- настоящий массив, с методами `map`, `forEach` и другими, в отличие от `arguments`.

[warn header="Оператор … должен быть в конце"]

Оператор `…` собирает "все оставшиеся" аргументы, поэтому такое объявление не имеет смысла:
```js
function f(arg1, ...rest, arg2) {
  // будет ошибка
}
```
[/warn]


Выше мы увидели использование `...` для чтения параметров внутри функции. Но этот же оператор можно использовать и для передачи массива параметров как списка, например:

```js
//+ run
'use strict';

let numbers = [2, 3, 15];

// Передаст массив как список аргументов: Math.max(2, 3, 15)
let max = Math.max(*!*...numbers*/!*);

alert( max ); // 15
```

Эти два вызова делают одно и то же:

```js
Math.max(...numbers);
Math.max.apply(Math, numbers);
```

## Деструктуризация в параметрах

Если функция получает объект, то она может его тут же разбить в переменные:

```js
//+ run
'use strict';

let menuOptions = {
  title: "Меню",
  width: 100,
  height: 200
};

*!*
function showMenu({title, width, height}) {
*/!*
  alert(`${title} ${width} ${height}`); // Меню 100 200
}

showMenu(menuOptions);
```

Можно использовать и более сложную деструктуризацию, с соответствиями и значениями по умолчанию:

```js
//+ run
'use strict';

let menuOptions = {
  title: "Меню"
};

*!*
function showMenu({title="Заголовок", width:w=100, height:h=200} = {}) {
*/!*
  alert(`${title} ${w} ${h}`); 
}

showMenu(menuOptions); // Меню 100 200

showMenu(); // Заголовок 100 200
```

## Имя "name"

В свойстве `name` у функции находится её имя.

Например:

```js
//+ run
'use strict';

function f() {} // f.name == "f"

let g = function g() {}; // g.name == "g"

alert(`${f.name} ${g.name}`) // f g
```

В примере выше показаны Function Declaration и Named Function Expression.

Но современный JavaScript идёт дальше, он старается даже анонимным функциям дать разумные имена.

Например, при создании анонимной функции с одновременной записью в переменную или свойство -- её имя равно названию переменной (или свойства):

```js
'use strict';

let g = function() {}; // g.name == "g"

let user = {
  sayHi: function() { }; // user.sayHi.name == "sayHi"
}
```

## Функции в блоке

Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке.

Например:

```js
//+ run
'use strict';

if (true) {

  sayHi(); // работает

  function sayHi() { 
    alert("Привет!");
  }

}
sayHi(); // ошибка, функции не существует
```

То есть, иными словами, такое объявление -- ведёт себя так же как `let sayHi = function ...`, сделанное в начале блока.

## Функции через =>

Появился новый синтаксис для задания функций через "стрелку" `=>`.

Его простейший вариант выглядит так:
```js
//+ run
'use strict';

*!*
let inc = x => x+1;
*/!*

alert( inc(1) ); // 2
```

То есть, слева от `=>` находится аргумент, а справа -- выражение, которое нужно вернуть.

Эти две записи -- примерно аналогичны:

```js
let inc = x => x+1;

let inc = function(x) { return x + 1; };
```

Если аргументов несколько, они оборачиваются в скобки, например:

```js
//+ run
'use strict';

let sum = (a,b) => a + b;

alert( sum(1, 2) ); // 3
```

...А если совсем нет аргументов, но функцию хочется задать, то используются пустые скобки:

```js
//+ run
'use strict';

let getTime = () => 
  `${new Date().getHours()} : ${new Date().getMinutes()}`;

alert( getTime() ); // текущее время
```


Когда тело функции достаточно большое, то можно его обернуть в `{…}`:


```js
//+ run
'use strict';

let getTime = () => {
  let date = new Date();
  let hours = date.getHours();
  let minutes = date.getMinutes();
  return `${hours}:${minutes}`;
};

alert( getTime() ); // текущее время
```

Заметим, что как только тело функции оборачивается в `{…}`, то оно уже автоматически ничего не возвращает. Нужно делать явный `return`, как в примере выше.

Функции-стрелки очень удобны в качестве коллбеков, например:

```js
//+ run
`use strict`;

let arr = [5, 8, 3];

let sorted = arr.sort( (a,b) => a - b ); 

alert(sorted); // 3, 5, 8
```

## Функции-стрелки не имеют своего this

Внутри `this` -- тот же, что и снаружи. 

Это очень удобно в обработчиках событий и коллбэках, например:

```js
//+ run
'use strict';

let group = {
  title: "Наш курс",
  students: ["Вася", "Петя", "Даша"],

  showList: function() {
*!*
    this.students.forEach( 
      (student) => alert(`${this.title}: ${student}`) 
    )
*/!*
  }
}

group.showList();
// Наш курс: Вася
// Наш курс: Петя
// Наш курс: Даша
```

Здесь в `forEach` была использована функция-стрелка, поэтому `this.title` внутри -- это `group.title`.

Если бы была обычная функция, то была бы ошибка:

```js
//+ run
'use strict';

let group = {
  title: "Наш курс",
  students: ["Вася", "Петя", "Даша"],

  showList: function() {
*!*
    this.students.forEach(function(student) {
      alert(`${this.title}: ${student}`); // будет ошибка
    })
*/!*
  }
}

group.showList();
```

При запуске будет "попытка прочитать свойство `title` у `undefined`", так как `.forEach(f)` при запуске `f` не ставит `this`.

...Вместе с тем, отсутствие у функции-стрелки "своего `this`" влечёт за собой естественное ограничение: такие функции нельзя использовать в качестве конструктора.

## Функции-стрелки не имеют своего arguments

В качестве `arguments` используются аргументы внешней "обычной" функции.

Например:

```js
//+ run
'use strict';

function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```

Выведется `1` из аргументов функции `f`. Функция-стрелка здесь вызвана без параметров, но это не важно: `arguments` берутся из внешней функции.

Сохранение внешнего `this` и `arguments` удобно использовать для форвардинга вызовов и создания декораторов.

Например, декоратор `defer(f, ms)` ниже получает функцию `f` и возвращает обёртку вокруг неё, откладывающую вызов на `ms` миллисекунд:

```js
//+ run
'use strict';

*!*
function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms)
  }
}
*/!*

function sayHi(who) { 
  alert(`Привет, ${who}!`);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("Вася"); // Привет, Вася! через 2 секунды
```

Аналогичная реализация без функции-стрелки выглядела бы так:

```js
function defer(f, ms) {
  return function() {
    let args = arguments;
    let ctx = this; 
    setTimeout(function() {
      return f.apply(ctx, args);
    }, ms);
  }
}
```











