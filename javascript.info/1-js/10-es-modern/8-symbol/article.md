
# Тип данных Symbol

Новый примитивный тип данных Symbol служит для создания уникальных идентификаторов.


## Объявление

Синтаксис:
```js
//+ run
'use strict';

let name = Symbol();
alert( typeof name ); // symbol
```

Обратим внимание, не `new Symbol`, а просто `Symbol`, так как это -- примитив.

Каждый символ -- уникален.

У функции `Symbol` есть необязательный аргумент "имя символа". Можно его использовать для описания символа, в целях отладки:

```js
//+ run
'use strict';

let name = Symbol("name");
alert( name.toString() ); // Symbol(name)
```

При этом если у двух символов одинаковое имя, то они *не равны*:

```js
//+ run
alert( Symbol("name") == Symbol("name") ); // false
```

То есть, ещё раз заметим, что каждый символ -- уникален.

## Глобальные символы

Существует "глобальный реестр" символов, который позволяет, при необходимости, разделять символы между частями программы.

Для чтения (или создания, если нет) "глобального" символа служит вызов `Symbol.for(имя)`:

```js
//+ run
'use strict';

// создание символа в реестре
let name = Symbol.for("name");

// символ уже есть, чтение из реестра
alert( Symbol.for("name") == name ); // true
```

Вызов `Symbol.keyFor(sym)` позволяет получить по глобальному символу его имя:


```js
//+ run
'use strict';

// создание символа в реестре
let name = Symbol.for("name");

// получение имени символа
alert( Symbol.keyFor(name) ); // name
```
[warn header="`Symbol.keyFor` возвращает `undefined`, если символ не глобальный"]
Заметим, что `Symbol.keyFor` работает *только для глобальных символов*, для остальных будет возвращено `undefined`:

```js
//+ run
'use strict';

alert( Symbol.keyFor(Symbol.for("name")) ); // name, глобальный
alert( Symbol.keyFor(Symbol("name2")) ); // undefined, обычный символ
```
[/warn]

## Использование символов

Особенность символов -- в том, что если в объект записать свойство-символ, то оно не участвует в итерации:

```js
//+ run
'use strict';

let isAdmin = Symbol("isAdmin");

let user = {
  name: "Вася",
  age: 30,
  [isAdmin]: true
};

alert( Object.keys(user) ); // name, age
for(let key in user) alert(key); // name, age
```

В примере выше выведутся все свойства, кроме символьного.

Это нужно в первую очередь для различных системных свойств, которых в современном JavaScript очень много.

Их список есть в спецификации, в таблице [Well-known Symbols](http://www.ecma-international.org/ecma-262/6.0/index.html#table-1).

В спецификации принято для краткости обозначать их как '@@имя', например `@@iterator`, но доступны они как свойства `Symbol`.

Например:
<ul>
<li>`Symbol.toPrimitive` -- идентификатор для свойства, задающего функцию преобразования объекта в примитив.</li>
<li>`Symbol.iterator` -- идентификатор для свойства, задающего функцию итерации по объекту.</li>
<li>...и т.п.</li>
</ul>

Смысл здесь в том, что допустим надо добавить к объекту "особый" функционал, например преобразование к примитиву или функцию итерации, или ещё что-то... 

Новый стандарт не мог просто сказать, что "свойство obj.toPrimitive теперь системное, оно делает то-то и то-то". Ведь свойство с таким именем, вполне возможно, используется в существующем коде. И он сломался бы.

Поэтому ввели целый тип "символы", которые можно использовать для задания свойств, которые уникальны, не участвуют в итерации и заведомо не конфликтуют со старым кодом.

Например:
```js
//+ run
'use strict';

let obj = { 
  iterator: 1, 
  [Symbol.iterator]: function() {}
}

alert(obj.iterator); // 1, символ не конфликтует
```

Чтобы получить символы, есть особый вызов [Object.getOwnPropertySymbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols).

Эта функция возвращает все символы в объекте. Заметим, что `getOwnPropertyNames` символы не возвращает.

```js
//+ run
'use strict';

let obj = { 
  iterator: 1, 
  [Symbol.iterator]: function() {}
}

// один символ в объекте
alert( Object.getOwnPropertySymbols(obj) ); // Symbol(Symbol.iterator)
```



Один из самых известных и полезных символов -- это `Symbol.iterator`. Мы будем активно его использовать позже, в главе про итераторы.

## Итого

<ul>
<li>Символы -- новый примитивный тип, предназначенный для уникальных идентификаторов.</li>
<li>Все символы уникальны, символы с одинаковым именем не равны друг другу.</li>
<li>Существует глобальный реестр символов, доступных через метод `Symbol.for(name)`. Для глобального символа можно получить имя вызовом и `Symbol.keyFor(sym)`.</li>
<li>Основная область использования символов -- это системные свойства объектов. Поддержка у них пока небольшая, но она растёт. Символы позволяют добавлять в стандарт новые "особые" свойства объектов, при этом не резервируя соответствующие названия.</li>
</ul>




