
# Тип данных Symbol

Новый примитивный тип данных Symbol служит для создания уникальных идентификаторов.


## Объявление

Синтаксис:
```js
//+ run
'use strict';

let name = Symbol();
alert( typeof name ); // symbol
```

Обратим внимание, не `new Symbol`, а просто `Symbol`, так как это -- примитив.

Каждый символ -- уникален.

У функции `Symbol` есть необязательный аргумент "имя символа". Можно его использовать для описания символа, в целях отладки:

```js
//+ run
'use strict';

let name = Symbol("name");
alert( name.toString() ); // Symbol(name)
```

При этом если у двух символов одинаковое имя, то они *не равны*:

```js
//+ run
alert( Symbol("name") == Symbol("name") ); // false
```

То есть, ещё раз заметим, что каждый символ -- уникален.

## Глобальные символы

Существует "глобальный реестр" символов, который позволяет, при необходимости, разделять символы между частями программы.

Для чтения (или создания, если нет) "глобального" символа служит вызов `Symbol.for(имя)`:

```js
//+ run
'use strict';

// создание символа в реестре
let name = Symbol.for("name");

// символ уже есть, чтение из реестра
alert( Symbol.for("name") == name ); // true
```

Вызов `Symbol.keyFor(sym)` позволяет получить по глобальному символу его имя:


```js
//+ run
'use strict';

// создание символа в реестре
let name = Symbol.for("name");

// получение имени символа
alert( Symbol.keyFor(name) ); // name
```
[warn header="`Symbol.keyFor` возвращает `undefined`, если символ не глобальный"]
Заметим, что `Symbol.keyFor` работает *только для глобальных символов*, для остальных будет возвращено `undefined`:

```js
//+ run
'use strict';

alert( Symbol.keyFor(Symbol.for("name")) ); // name, глобальный
alert( Symbol.keyFor(Symbol("name2")) ); // undefined, обычный символ
```
[/warn]

## Использование символов

Символы используются в качестве имён для методов и свойств объекта, которые являются системными, или которые необходимо скрыть.

Особенность символов -- в том, что если в объект записать свойство-символ, то оно не участвует в итерации:

```js
//+ run
'use strict';

let isAdmin = Symbol("isAdmin");

let user = {
  name: "Вася",
  age: 30,
  [isAdmin]: true
};

alert( Object.keys(user) ); // name, age
for(let key in user) alert(key); // name, age
```

В примере выше выведутся все свойства, кроме символьного.

В современно JavaScript есть много системных символов. Их список есть в спецификации, в таблице [Well-known Symbols](http://www.ecma-international.org/ecma-262/6.0/index.html#table-1). В спецификации принято символы для краткости обозначать их как '@@имя', например `@@iterator`, но доступны они как свойства `Symbol`.

Например:
<ul>
<li>`Symbol.toPrimitive` -- идентификатор для свойства, задающего функцию преобразования объекта в примитив.</li>
<li>`Symbol.iterator` -- идентификатор для свойства, задающего функцию итерации по объекту.</li>
<li>...и т.п.</li>
</ul>

Мы легко поймём смысл введения нового типа "символ", если поставим себя на место создателей языка JavaScript.

Допустим, надо добавить к объекту "особый" функционал, например, функцию, которая задаёт преобразование объекта к примитиву.

Можно, конечно, сказать, что "свойство obj.toPrimitive теперь системное, оно делает то-то и то-то". Но это опасно. Мало ли, вполне возможно, что свойство с таким именем уже используется в существующем коде. И если сделать его системным, то он сломается.

Нельзя просто взять и зарезервировать какие-то свойства существующих объектов для нового функционала.

Поэтому ввели целый тип "символы". Их можно использовать для задания свойств, которые уникальны, не участвуют в итерации и заведомо не конфликтуют со старым кодом.

Например:
```js
//+ run
'use strict';

let obj = { 
  iterator: 1, 
  [Symbol.iterator]: function() {}
}

alert(obj.iterator); // 1
alert(obj[Symbol.iterator]) // function, символ не конфликтует
```

Выше мы использовали системный символ `Symbol.iterator`, поскольку он один из самых широко поддерживаемых. Мы подробно разберём его смысл в следующих главах, пока же -- это просто пример символа.

Чтобы получить все символы объекта, есть особый вызов [Object.getOwnPropertySymbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols).

Эта функция возвращает все символы в объекте. Заметим, что `getOwnPropertyNames` символы не возвращает.

```js
//+ run
'use strict';

let obj = { 
  iterator: 1, 
  [Symbol.iterator]: function() {}
}

// один символ в объекте
alert( Object.getOwnPropertySymbols(obj) ); // Symbol(Symbol.iterator)

// и одно обычное свойство
alert( Object.getOwnPropertyNames(obj) ); // iterator
```

## Итого

<ul>
<li>Символы -- новый примитивный тип, предназначенный для уникальных идентификаторов.</li>
<li>Все символы уникальны, символы с одинаковым именем не равны друг другу.</li>
<li>Существует глобальный реестр символов, доступных через метод `Symbol.for(name)`. Для глобального символа можно получить имя вызовом и `Symbol.keyFor(sym)`.</li>
</ul>

Основная область использования символов -- это системные свойства объектов. Поддержка у них пока небольшая, но она растёт. Системные символы позволяют добавлять в стандарт новые "особые" свойства объектов, при этом не резервируя соответствующие названия.

Но, конечно, мы можем создавать и свои локальные и глобальные символы, использовать их в своих объектах. 

