
# Set, Map, WeakSet и WeakMap

Новые типы коллекций в JavaScript: `Set`, `Map`, `WeakSet` и `WeakMap`.


## Map

`Map` -- коллекция для хранения записей вида `ключ: значение`.

В отличие от объектов, в которых ключами могут быть только строки, в `Map` ключом может быть произвольное значение, например:

```js
//+ run
'use strict';

let map = new Map();

map.set('1', 'str1');   // строка
map
  .set(1, 'num1')       // число
  .set(true, 'bool1');  // булевое

// в обычном объекте это было бы одно и то же
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'
```

Как видно из примера выше, для сохранения и чтения значений используются методы `get` и `set`, причём `set` можно чейнить.

**При создании `Map` можно сразу инициализовать списком значений.**

Объект `map` с тремя ключами, как и в примере выше:

```js
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
```

Аргументом `new Map` должен быть итерируемый объект (не обязательно именно массив), которые должен возвратить объект с ключами `0`,`1` -- также не обязательно массив. Везде утиная типизация, максимальная гибкость.

**В качестве ключей можно использовать и объекты:**

```js
//+ run
'use strict';

let user = { name: "Вася" };

let visitsCountMap = new Map();

*!*
// объект user является ключом в visitsCountMap
visitsCountMap.set(user, 123);
*/!*

alert( visitsCountMap.get(user) ); // 123
```

[smart header="Как map сравнивает ключи"]
Для проверки значений на эквивалентность используется алгоритм [SameValueZero](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevaluezero). Он аналогичен строгому равенству `===`, отличие -- в том, что `NaN` считается равным `NaN`.
[/smart]

Для удаления записей используется метод:
<ul>
<li>`map.delete(key)` -- возвращает `true`, если ключ существовал, иначе `false`.</li>
</ul>

Для проверки существования ключа:

<ul>
<li>`map.has(key)` -- возвращает `true`, если ключ есть, иначе `false`.</li>
</ul>

Ещё раз заметим, что используемый алгоритм сравнения ключей аналогичен `===`, за исключением `NaN`, которое равно самому себе:

```js
//+ run
'use strict';

let map = new Map([ [NaN: 1] ]);

alert( map.has(NaN) ); // true
alert( map.get(NaN) ); // 1
alert( map.delete(NaN) ); // true
```

### Итерация 

Для итерации используется один из трёх методов:
<ul>
<li>`map.keys()` -- возвращает итерируемый объект для ключей,</li>
<li>`map.values()` -- возвращает итерируемый объект для значений,</li>
<li>`map.entries()` -- возвращает итерируемый объект для записей `[ключ, значение]`, он используется по умолчанию в `for..of`.</li>
</ul>

Например:

```js
//+ run
'use strict';

let recipeMap = new Map([
  ['огурцов',   '500 гр'],
  ['помидоров', '350 гр'],
  ['сметаны',   '50 гр']
]);

for(let fruit of recipeMap.keys()) {
  alert(fruit); // огурцов, помидоров, сметаны
} 

for(let amount of recipeMap.values()) {
  alert(amount); // 500 гр, 350 гр, 50 гр
} 

for(let entry of recipeMap) { // то же что и recipeMap.entries()
  alert(entry); // огурцов,500 гр , и т.д., массивы по 2 значения
} 
```

Кроме того, у `Map` есть стандартный методы `forEach`, аналогичный массиву:

```js
//+ run
'use strict';

let recipeMap = new Map([
  ['огурцов',   '500 гр'],
  ['помидоров', '350 гр'],
  ['сметаны',   '50 гр']
]);

recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // огурцов: 500 гр, и т.д.
});
```








Есть и другие методы:

<ul>
<li>`map.size()` -- количество записей в


ToDo

