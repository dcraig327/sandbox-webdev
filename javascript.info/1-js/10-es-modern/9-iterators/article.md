 
# Итераторы

В современный JavaScript добавлена новая концепция "итерируемых" (iterable) объектов.

Итерируемые или, иными словами, "перебираемые" объекты -- это те, содержимое которых можно перебрать в цикле.

Например, массив, но не только он. В браузере существует множество объектов, которые не являются массивами, но содержимое которых можно перебрать (к примеру, список DOM-узлов), а итераторы дают возможность сделать "перебираемыми" любые объекты.

Для перебора таких объектов добавлен новый синтаксис цикла: `for..of`.

Например:

```js
//+ run
'use strict';

let arr = [1, 2, 3]; // массив — пример итерируемого объекта

for(let value of arr) {
  alert(value); // 1, затем 2, затем 3
}
```

Также итерируемой является строка:

```js
//+ run
'use strict';

for(let char of "Привет") {
  alert(char); // Выведет по одной букве: П, р, и, в, е, т
}
```


Итераторы -- расширяющая понятие "массив" концепция, которая пронизывает современный стандарт JavaScript сверху донизу.

Практически везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя не только строки, массивы, но и вызов функции с оператором spread `f(...args)`, и многое другое.

## Свой итератор

Допустим, у нас есть некий объект, который надо "умным способом" перебрать.

Например, `range` -- диапазон чисел от `range.from` до `range.to`:

```js
let range = {
  from: 1,
  to: 5
};
```

Для возможности использовать объект в `for..of` ему ставится свойство с названием `Symbol.iterator`. `Symbol.iterator` -- системный символ, который вызывает `for..of` в начале выполнения. 

При вызове метода `Symbol.iterator` перебираемый (итерируемый) объект должен возвращать другой объект ("итератор"), который умеет осуществлять перебор.

По стандарту у такого объекта должен быть метод `next()`, который при каждом вызове возвращает очередное значение и окончен ли перебор.

Так это выглядит в коде:

```js
//+ run
'use strict';

let range = {
  from: 1,
  to: 5
}

// сделаем объект range итерируемым
range[Symbol.iterator] = function() {

  let current = this.from;
  let last = this.to;

  // метод должен вернуть объект с next()
  return {
    next() {
      if (current <= last) {
        return {
          done: false,
          value: current++
        };
      } else {
        return {
          done: true
        };
      } 
    }

  }
};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
```

...То есть, здесь имеет место разделение сущностей:

<ul>
<li>Перебираемый объект сам не реализует методы для своего перебора. Для этого существует другой объект, который хранит текущее состояние перебора и возвращает значение.</li>
<li>Этот объект называется итератором и создаётся при вызове метода `Symbol.iterator`.</li>
<li>У итератора должен быть метод `next()`, который при каждом вызове возвращает объект со свойствами:
<ul>
<li>`value` -- очередное значение,
<li>`done` -- равно `false`, если есть ещё значения, и `true` -- в конце.</li>
</ul>
</li>
</ul>

Конструкция `for..of` получает итератор и вызывает метод `next()` прозрачно и автоматически до получения `done: true`.

Впрочем, хоть такое отделение функционала перебора от самого объекта даёт дополнительную гибкость, например, объект может возвращать разные итераторы в зависимости от своего настроения и времени суток, зачастую оно не нужно.

Чтобы функционал по перебору заключить в самом объекте, можно вернуть `this` в качестве итератора:


```js
//+ run
'use strict';

let range = {
  from: 1,
  to: 5,

*!*
  [Symbol.iterator]() {
    return this;
  },
*/!*

  next() {
    if (this.current === undefined) {
      // инициализация состояния итерации
      this.current = this.from;
    }

    if (this.current <= this.to) {
      return {
        done: false,
        value: this.current++
      };
    } else {
      // очистка текущей итерации
      delete this.current;
      return {
        done: true
      };
    } 
  }

};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}

// Произойдёт вызов Math.max(1,2,3,4,5);
alert( Math.max(...range) ); // 5 (*)

```

При таком подходе сам объект и хранит состояние итерации (текущий перебираемый элемент). 

В данном случае это работает, но для большей гибкости и понятности кода рекомендуется, всё же, выделять итератор в отдельный объект со своим состоянием и кодом.

В последней строке `(*)` можно видеть, что итерируемый объект передаётся через spread для `Math.max`. При этом spread превращает итератор в массив. То есть пройдёт цикл по итератору, с вызовами `next`, и его результаты будут использованы в качестве списка аргументов.

[smart header="Бесконечные итераторы"]
Возможны и бесконечные итераторы. Например, пример выше при `range.to = Infinity` будет таковым. Или можно сделать итератор, генерирующий бесконечную последовательность псевдослучайных чисел.

Нет никаких ограничений на `next`, он может возвращать всё новые и новые значения.

Разумеется, цикл `for..of` по такому итератору сам по себе не завершится, нужно его прерывать, например, через `break`.
[/smart]

## Встроенные итераторы

Итератор можно получить и без `for..of`, прямым вызовом `Symbol.iterator`.

Например, этот код получает итератор для строки и вызывает его полностью "вручную":

```js
//+ run
'use strict';

let str = "Hello";

// Делает то же, что и
// for(var letter of str) alert(letter);

let iterator = str[Symbol.iterator]();

while(true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // Выведет все буквы по очереди
}
```

## Итого

<ul>
<li>*Итератор* -- объект, предназначенный для перебора другого объекта.</li>
<li>У итератора должен быть метод `next()`, возвращающий `{done: Boolean, value: any}`, где `value` -- очередное значение, а `done: true` в конце.</li>
<li>Метод `Symbol.iterator` предназначен для получения итератора из объекта. Цикл `for..of` делает это автоматически, но можно и вызвать его напрямую.</li>
<li>В современном стандарте есть много мест, где вместо массива используются более абстрактные "итерируемые" (со свойством `Symbol.iterator`) объекты.</li>
<li>Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.</li>
</ul>






