
# Объекты и прототипы

В этом разделе мы рассмотрим нововведения, которые касаются именно объектов.

По классам -- чуть позже, в отдельном разделе, оно того заслуживает.


Для объектов есть очень приятные нововведения, которые касаются объявления свойств и методов. Новый синтаксис используется и в классах.

Нововведения в объектах и классах очень тесно взаимосвязаны, поэтому обе этих темы объединены в один раздел.

Мы начнём с объектов, а затем перейдём к классам.


## Короткое свойство

Зачастую у нас есть переменные, например, `name` и `isAdmin`, и мы хотим использовать их в объекте.

При объявлении объекта в этом случае достаточно указать только имя свойства, а значение будет взято из переменной с таким именем.

Например:

```js
//+ run
'use strict';

let name = "Вася";
let isAdmin = true;

*!*
let user = {
  name, 
  isAdmin
};
*/!*
alert( JSON.stringify(user) ); // {"name": "Вася", "isAdmin": true}
```


## Вычисляемые свойства

В качестве имени свойства можно использовать выражение, например:

```js
//+ run
'use strict';

let propName = "firstName";

let user = {
*!*
  [propName]: "Вася"
*/!*
};

alert( user.firstName ); // Вася
```

Или даже так:

```js
//+ run
'use strict';

let a = "Мой ";
let b = "Зелёный ";
let c = "Крокодил";

let user = {
*!*
  [(a + b + c).toLowerCase()]: "Вася"
*/!*
};

alert( user["мой зелёный крокодил"] ); // Вася
```


## Геттер-сеттер для прототипа

В ES5 для прототипа был метод-геттер:
<ul>
<li>`Object.getPrototypeOf(obj)`</li>
</ul>

В современной JavaScript также добавился сеттер:
<ul>
<li>`Object.setPrototypeOf(obj, newProto)`</li>
</ul>

...А также "узаконено" свойство `__proto__`, которое даёт прямой доступ к прототипу. Его, в качестве "нестандартного", но удобного способа работы с прототипом реализовали почти все браузеры (кроме IE10-), так что было принято решение добавить его в стандарт.

По стандарту оно реализовано через геттеры-сеттеры `Object.getPrototypeOf/setPrototypeOf`.


## Object.assign

Синтаксис:
```js
Object.assign(target, src1, src2...)
```

Функция `Object.assign` получает список объектов и копирует в первый `target` свойства из остальных.

Последующие свойства перезаписывают предыдущие.

Например:

```js
//+ run
'use strict';

let user = { name: "Вася" };
let visitor = { isAdmin: false, visits: true };
let admin = { isAdmin: true };

Object.assign(user, visitor, admin);

alert( JSON.stringify(user) ); // user: Вася, visits: true, isAdmin: true
```


## Методы объекта

Долгое время в JavaScript термин "метод объекта" был просто альтернативным названием для свойства-функции.

Теперь это уже не так, добавлены именно "методы объекта". Они отличаются от обычных свойств-функций наличием специального внутреннего свойства `[[HomeObject]]` ("домашний объект"), ссылающегося на объект, которому метод принадлежит.

Для объявления метода вместо записи `"prop: function() {…}"` нужно написать просто `"prop() { … }"`.

Например:

```js
//+ run
'use strict';

let name = "Вася";
let user = {
  name,
*!*
  /* вместо sayHi: function() { */
  sayHi() { 
    alert(this.name);
  }
*/!*
};

user.sayHi(); // Вася
```

Также методами станут объявления геттеров `get prop()` и сеттеров `set prop()`:

```js
//+ run
'use strict';

let name = "Вася", surname="Петров";
let user = {
  name,
  surname,
  get fullName() {
    return `${name} ${surname}`;
  }
};

alert( user.fullName ); // Вася Петров
```

Основное отличие "методов" от "просто функций" -- возможность обратиться к "родительскому методу" через ключевое слово `super`, о котором пойдёт речь дальше.


## super

Ссылка `super` позволяет из метода обратиться к прототипу объекта.

Например, в коде ниже `super.walk` из `rabbit` обращается к `animal.walk`:

```js
//+ run
'use strict';

let animal = { 
  walk() { 
    alert("I'm walking");
  }
};

let rabbit = { 
  __proto__: animal,
  walk() {
*!*
    alert(super.walk); // walk() { … }
    super.walk(); // I'm walking
*/!*
  }
};

rabbit.walk();
```

При обращении через `super` используется `[[HomeObject]]` текущего метода, и от него берётся `__proto__`. Поэтому `super` работает только внутри методов.

Например, тот же код, но со свойством-функцией `walk` вместо метода в `rabbit`:

```js
//+ run
'use strict';

let animal = { 
  walk() { 
    alert("I'm walking");
  }
};

let rabbit = { 
  __proto__: animal,
*!*
  walk: function() {
    super.walk(); // Будет ошибка!
  }
*/!*
};

rabbit.walk();
```

Будет ошибка, так как `rabbit.walk` теперь обычная функция, и не имеет `[[HomeObject]]`. 

Исключением из этого правила являются функции-стрелки. В них используется `super` внешней функции.

Например, здесь функция-стрелка в `setTimeout` берёт внешний `super`:


```js
//+ run
'use strict';

let animal = { 
  walk() { 
    alert("I'm walking");
  }
};

let rabbit = { 
  __proto__: animal,
  walk() {
*!*
    setTimeout(() => super.walk()); // I'm walking
*/!*
  }
};

rabbit.walk();
```

[smart header="Свойство `[[HomeObject]]` -- не изменяемое"]

При создании метода -- он привязан к своему объекту навсегда. Технически можно даже скопировать его и запустить независимо:

```js
//+ run
'use strict';

let animal = { 
  walk() { alert("I'm walking"); }
};

let rabbit = { 
  __proto__: animal,
  walk() {
    super.walk();
    alert(this);
  }
};

let walk = rabbit.walk; // скопируем метод в переменную
*!*
walk(); 
// I'm walking
// undefined
*/!*
```

В примере выше метод `walk()` запускается отдельно от объекта, но всё равно сохраняется через `super` доступ к его прототипу, благодаря `[[HomeObject]]`. 

Это относится именно к `super`. Правила `this` для методов те же, в примере выше будет `undefined`.
[/smart]

