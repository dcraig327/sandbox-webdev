# Операторы сравнения и логические значения

В этом разделе мы познакомимся с операторами сравнения и с логическими значениями, которые такие операторы возвращают.
[cut]
Многие операторы сравнения знакомы нам со школы:

<ul>
<li>Больше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.</li>
<li>Больше/меньше или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.</li>
<li>Равно `a == b`. 
Для сравнения используется два символа равенства `'='`. Один символ `a = b` означал бы присваивание.</li>
<li>"Не равно". В школе он пишется как <code>&ne;</code>, в JavaScript -- знак равенства с восклицательным знаком перед ним <code>!=</code>.</li>
</ul>

## Логические значения

Как и другие операторы, сравнение возвращает значение. Это значение имеет специальный *логический* тип. 

Существует всего два логических значения:
<ul>
<li>`true` -- имеет смысл "да", "верно", "истина".</li>
<li>`false` -- означает "нет", "неверно", "ложь".</li>
</ul>

Например:

```js
//+ run
alert( 2 > 1 ); // true, верно
alert( 2 == 1 ); // false, неверно
alert( 2 != 1 ); // true
```

Логические значения можно использовать и напрямую, присваивать переменным, работать с ними как с любыми другими:

```js
//+ run
var a = true; // присвоили явно
var b = 3 > 4; // false

alert( b ); // false

alert( a == b ); // (true == false) неверно, результат false
```

## Сравнение строк

Строки сравниваются побуквенно:

```js
//+ run
alert( 'Б' > 'А' ); // true
```

[warn header="Осторожно, Unicode!"]
Аналогом "алфавита" во внутреннем представлении строк служит кодировка, у каждого символа -- свой номер (код). JavaScript использует кодировку [Unicode](http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4). 

При этом сравниваются *численные коды символов*. В частности, код у символа `Б` больше, чем у `А`, поэтому и результат сравнения такой.

**В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.**

Поэтому регистр имеет значение:

```js
//+ run
alert('а' > 'Я'); // true, строчные буквы больше прописных
```

Для корректного сравнения символы должны быть в одинаковом регистре. 
[/warn]

Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.

Иными словами, больше -- та строка, которая в телефонной книге была бы на большей странице. 

Например:
<ul>
<li>Если первая буква первой строки больше -- значит первая строка больше, независимо от остальных символов:

```js
//+ run
alert( 'Банан' > 'Аят' );
```

</li>
<li>Если одинаковы -- сравнение идёт дальше. Здесь оно дойдёт до третьей буквы:

```js
//+ run
alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'
```

</li>
<li>При этом любая буква больше отсутствия буквы:

```js
//+ run
alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем "ничего".
```

</li>
</ul>
Такое сравнение называется *лексикографическим*. 


[warn]
Обычно мы получаем значения от посетителя в виде строк. Например, `prompt` возвращает *строку*, которую ввел посетитель. 

Числа, полученные таким образом, в виде строк сравнивать нельзя, результат будет неверен. Например:

```js
//+ run
alert( "2" > "14" ); // true, неверно, ведь 2 не больше 14
```

В примере выше `2` оказалось больше `14`, потому что строки сравниваются посимвольно, а первый символ `'2'` больше `'1'`. 

Правильно было бы преобразовать их к числу явным образом. Например, поставив перед ними `+`:

```js
//+ run
alert( +"2" > +"14" ); // false, теперь правильно
```

[/warn]

## Сравнение разных типов

При сравнении значения преобразуются к числам. Исключение: когда оба значения -- строки, тогда не преобразуются.

Например:

```js
//+ run
alert( '2' > 1 ); // true
alert( '01' == 1 ); //true
alert( false == 0 ); // true, false становится 0, а true 1.
```

Тема преобразований типов будет продолжена далее, в главе [](/types-conversion). 

## Строгое равенство

Обычное равенство не может отличить `0` от `false`:

```js
//+ run
alert(0 == false); // true, так как false преобразуется к 0
```

Что же делать, если всё же нужно отличить `0` от `false`? 

**Для проверки равенства без преобразования типов используются операторы строгого равенства `===` (тройное равно) и `!==`.**

Они сравнивают без приведения типов. Если тип разный, то такие значения всегда неравны (строго):

```js
//+ run
alert(0 === false); // false, т.к. типы различны
```

Строгое сравнение предпочтительно, если мы хотим быть уверены, что "сюрпризов" не будет.

## Сравнение с null и undefined

Проблемы со специальными значениями возможны, когда к переменной применяется операция сравнения `> < <= >=`, а у неё может быть как численное значение, так и `null/undefined`. 

**Интуитивно кажется, что `null/undefined` эквивалентны нулю, но это не так! Они ведут себя по-другому.**
 
<ol>
<li>**Значения `null` и `undefined` равны `==` друг другу и не равны чему бы то ни было ещё.** 
Это жёсткое правило буквально прописано в спецификации языка.</li>
<li>**При преобразовании в число `null` становится `0`, а `undefined` становится `NaN`.**</li>
</ol>

Посмотрим забавные следствия.

[smart header="Некорректный результат сравнения `null` с `0`"]
Сравним `null` с нулём:

```js
//+ run
alert(null > 0); // false
alert(null == 0); // false
```

Итак, мы получили, что `null` не больше и не равен нулю. А теперь...

```js
//+ run
alert(null >= 0); // *!*true*/!*
```

Как такое возможно? Если нечто *"больше или равно нулю"*, то резонно полагать, что оно либо *больше*, либо *равно*. Но здесь это не так.

Дело в том, что алгоритмы проверки равенства `==` и сравнения `>= > < <=` работают по-разному.

Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения `null` и `undefined` обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё. 

В результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше. 

[/smart]

[smart header="Несравнимый `undefined`"]
Значение `undefined` вообще нельзя сравнивать:

```js
//+ run
alert(undefined > 0); // false (1)
alert(undefined < 0); // false (2)
alert(undefined == 0); // false (3)
```

<ul>
<li>Сравнения `(1)` и `(2)` дают `false` потому, что `undefined` при преобразовании к числу даёт `NaN`. А значение `NaN` по стандарту устроено так, что сравнения `==`, `<`, `>`, `<=`, `>=` и даже `===` с ним возвращают `false`.</li>
<li>Проверка равенства `(3)` даёт `false`, потому что в стандарте явно прописано, что `undefined` равно лишь `null` и ничему другому.</li>
</ul>
[/smart]

**Вывод: любые сравнения с `undefined/null`, кроме точного `===`, следует делать с осторожностью.**

Желательно не использовать сравнения `>= > < <=` с ними, во избежание ошибок в коде.


## Итого

<ul>
<li>В JavaScript есть логические значения `true` (истина) и `false` (ложь). Операторы сравнения возвращают их.</li>
<li>Строки сравниваются побуквенно.</li>
<li>Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства `===` (`!==`).</li>
<li>Значения `null` и `undefined` равны `==` друг другу и не равны ничему другому. В других сравнениях (с участием `>`,`<`) их лучше не использовать, так как они ведут себя не как `0`.</li>
</ul>