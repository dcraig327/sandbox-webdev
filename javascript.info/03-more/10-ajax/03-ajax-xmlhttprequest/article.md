# Основы XMLHttpRequest

Объект `XMLHttpRequest` (или, как его кратко называют, "XHR") дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.

Несмотря на слово "XML" в названии, `XMLHttpRequest` может работать с любыми данными, а не только с XML.

Использовать его очень просто.

[cut]

## Пример использования

Как правило, `XMLHttpRequest` используют для загрузки данных. 

Разберём его на примере ниже, в котором JavaScript осуществит загрузку файла `phones.json` и вывод содержимого:

[iframe src="phones" border="1" zip]

Код, который выполняется при нажатии на кнопку, по шагам:

```js
*!*
// 1. Создаём новый объект XMLHttpRequest
*/!*
var xhr = new XMLHttpRequest(); 

*!*
// 2. Конфигурируем его: GET-запрос на URL 'phones.json'
xhr.open('GET', 'phones.json', false); 
*/!*

*!*
// 3. Отсылаем запрос
*/!*
xhr.send(); 

*!*
// 4. Если код ответа сервера не 200, то это ошибка
*/!*
if (xhr.status != 200) {
  // обработать ошибку
  alert(xhr.status + ': ' + xhr.statusText); // пример вывода: 404: Not Found 
} else {
  // вывести результат
  alert(xhr.responseText); // responseText -- текст ответа.
}
```

Далее мы более подробно разберём основные методы и свойства `xhr`.

## Методы open, send и abort

Эти три метода управляют основным потоком запроса:

<dl>
<dt>`open(method, URL, async, user, password)`</dt>
<dd>
Задаёт основные параметры запроса:
<ul>
<li>`method` -- HTTP-метод. Как правило, используется GET либо POST, хотя доступны и более экзотические, вроде TRACE/DELETE/PUT и т.п.</li>
<li>`URL` -- адрес запроса. Можно использовать не только http/https, но и другие протоколы, например `ftp://` и `file://`.

**При этом есть ограничения безопасности, называемые "Same Origin Policy": запрос со страницы можно отправлять только на тот же `протокол://домен:порт`, с которого она пришла. В следующих главах мы рассмотрим, как их можно обойти.**
</li>
<li>`async` -- если установлено в `false`, то запрос производится синхронно, если `true` -- асинхронно.

"Синхронный запрос" означает, что после вызова `xhr.send()` и до ответа сервера главный поток будет "заморожен": посетитель не сможет взаимодействовать со страницей -- прокручивать, нажимать на кнопки и т.п. После получения ответа выполнение продолжится со следующей строки.

"Асинхронный запрос" означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий, которые мы рассмотрим далее.
</li>
<li>`user`, `password` -- логин и пароль для HTTP-авторизации, если нужны.</li>
</ul>

</dd>
<dt>`send([body])`</dt>
<dd>Отправить запрос на сервер.

В `body` находится *тело* запроса. Не у всякого запроса есть тело, например у GET-запросов тела нет.

С другой стороны, в POST основные данные как раз передаются через `body`.</dd>
<dt>`abort()`</dt>
<dd>Прерывает выполнение запроса.</dd>
</dl>

## Свойства status, statusText, responseText и responseXML

Основные свойства, содержащие ответ сервера:

<dl>
<dt>`status`</dt>
<dd>HTTP-код ответа: `200`, `404`, `403` и так далее. Может быть также равен `0`, если сервер не ответил или при запросе на другой домен.</dd>
<dt>`statusText`</dt>
<dd>Текстовое описание статуса от сервера: `OK` `Not Found`, `Forbidden` и так далее.</dd>
<dt>`responseText`</dt>
<dd>Ответ сервера в виде текста.</dd>
<dt>`responseXml`</dt>
<dd>Если сервер вернул XML, снабдив его правильным заголовком `Content-type: text/xml`, то браузер создаст из него XML-документ. По нему можно будет делать запросы `xhr.responseXml.querySelector("...")` и другие.

Как правило, при общении с сервером используют не XML, а JSON. То есть, сервер возвращает JSON в виде текста, который  браузер превращает в объект вызовом `JSON.parse(xhr.responseText)`.
</dd>
</dl>


## Асинхронный вызов

Синхронные вызовы имеют ряд важных отличий от асинхронных:

<ul>
<li>Блокируют взаимодействие со страницей до окончания загрузки. Посетитель не может даже прокручивать её.</li>
<li>Если синхронный вызов занял слишком много времени, то браузер предложит закрыть "зависшую" страницу.</li>
<li>Кроме того, забегая вперёд, заметим, что ряд продвинутых возможностей, таких как возможность делать запросы на другой домен и указывать таймаут, в синхронном режиме не работают.</li>
</ul>

**Поэтому, как правило, используют асинхронные вызовы.**

Для того, чтобы запрос стал асинхронным, укажем параметр `async` равным `true`.

Демо:

[iframe src="phones-async" border zip]

JS-код изменился:

```js
var xhr = new XMLHttpRequest();

xhr.open('GET', 'phones.json', *!*true*/!*);

*!*
xhr.onreadystatechange = function() { // (3)
  if (xhr.readyState != 4) return;
*/!*

  button.innerHTML = 'Готово!';

  if (xhr.status != 200) {
    alert(xhr.status + ': ' + xhr.statusText);
  } else {
    alert(xhr.responseText);
  }

}

xhr.send(); // (1)

button.innerHTML = 'Загружаю...'; // (2)
button.disabled = true;
```

Теперь мы отправляем запрос асинхронно: 
<ol>
<li>JavaScript продолжает выполнение после `xhr.send()`.</li>
<li>Для того, чтобы показать, что задача "в процессе" -- мы меняем текст кнопки `button`.</li>
<li>Скрипт завершается, страница полностью активна, а ответ, когда он появится, вызовет обработчик `onreadystatechange`.</li>
</ol>

**Событие `readystatechange` происходит несколько раз в процессе отсылки и получения ответа. При этом можно посмотреть "текущее состояние запроса" в свойстве `xhr.readyState`.**

Все состояния, по [спецификации](http://www.w3.org/TR/XMLHttpRequest/#states):

```js
const unsigned short UNSENT = 0; // начальное состояние
const unsigned short OPENED = 1; // вызван open
const unsigned short HEADERS_RECEIVED = 2; // получены заголовки
const unsigned short LOADING = 3; // загружается тело (получен очередной пакет данных)
const unsigned short DONE = 4; // запрос завершён
```

Запрос проходит их в порядке `0` -> `1` -> `2` -> `3` -> ... -> `3` -> `4`, состояние `3` повторяется при каждом получении очередного пакета данных по сети.

В данном случае нас интересует состояние `4` (запрос завершён).

Пример ниже демонстрирует переключение между состояниями. В нём сервер отвечает на запрос `digits`, пересылая по строке из 1000 цифр раз в секунду.

[iframe src="readystate" height=200 border zip]

[warn header="Точка разрыва не гарантирована"]
При `readyState=3` мы можем посмотреть текущие данные в `responseText` и, казалось бы, могли бы работать с этими данными как с "ответом на текущий момент".

Однако, технически мы не управляем разрывами между сетевыми пакетами. Если протестировать пример выше в локальной сети, то в большинстве браузеров разрывы будут каждые 1000 символов, но в реальности событие может возникнуть на любом байте. 

Вплоть до того, что символ русского языка в кодировке UTF-16 кодируется двумя байтами -- и разрыв может возникнуть *между ними*. 

Получится, что при очередном `readyState` в конце `responseText` будет байт-полсимвола, то есть он не будет корректной строкой -- частью ответа! Если скрипт будет предполагать, что это -- полноценная часть ответа, то неизбежны глюки.
[/warn]


## HTTP-заголовки, методы *RequestHeader

`XMLHttpRequest` умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.

Для работы с HTTP-заголовками есть 3 метода:

<dl>
<dt>`setRequestHeader(name, value)`</dt>
<dd>Устанавливает заголовок `name` запроса со значением `value`. 

Например:

```js
xhr.setRequestHeader('Content-Type', 'application/json');
```

[warn header="Ограничения на заголовки"]
Нельзя установить заголовки, которые контролирует браузер, например `Referer` или `Host` и ряд других (полный список [тут](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method)). 

Это ограничение существует в целях безопасности и для контроля корректности запроса. 
[/warn]

[warn header="Поставленный заголовок нельзя снять"]
Особенностью `XMLHttpRequest` является то, что отменить `setRequestHeader` невозможно.

Повторные вызовы добавляют информацию к заголовку:

```js
xhr.setRequestHeader('X-Auth', '123');
xhr.setRequestHeader('X-Auth', '456');

// в результате будет заголовок:
// X-Auth: 123, 456
```

[/warn]

</dd>
<dt>`getResponseHeader(name)`</dt>
<dd>Возвращает значение заголовка ответа `name`, кроме `Set-Cookie` и `Set-Cookie2`.

Например:

```js
xhr.getResponseHeader('Content-Type')
```

</dd>
<dt>`getAllResponseHeaders()`</dt>
<dd>Возвращает все заголовки ответа, кроме `Set-Cookie` и `Set-Cookie2`.

Заголовки возвращаются в виде единой строки, например:

```
Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT
```

Между заголовками стоит перевод строки в два символа `"\r\n"` (не зависит от ОС), значение заголовка отделено двоеточием с пробелом `": "`. Этот формат задан стандартом.

Таким образом, если хочется получить объект с парами заголовок-значение, то эту строку необходимо разбить и обработать.
</dd>
</dl>


## Таймаут: свойство и событие timeout

Максимальную продолжительность запроса можно задать свойством `timeout`:

```js
xhr.timeout = 30000; // 30 секунд (в миллисекундах)
```

При превышении этого времени запрос будет оборван и сгенерировано событие `ontimeout`:

```js
xhr.ontimeout = function() {
  alert('Извините, запрос превысил максимальное время');
}
```

## Полный список событий загрузки

Современная [спецификация](http://www.w3.org/TR/XMLHttpRequest/#events) предусматривает следующие события:

<ul>
<li>`loadstart` -- запрос начат.</li>
<li>`progress` -- браузер получил очередной пакет данных, можно прочитать текущие полученные данные в `responseText`.</li>
<li>`abort` -- запрос был отменён вызовом `xhr.abort()`.</li>
<li>`error` -- произошла ошибка.</li>
<li>`load` -- запрос был успешно (без ошибок) завершён.</li>
<li>`timeout` -- запрос был прекращён по таймауту.</li>
<li>`loadend` -- запрос был завершён (успешно или неуспешно)</li
</ul>

Используя эти события можно более удобно отслеживать загрузку (`onload`) и ошибку (`onerror`), а также количество загруженных данных (`onprogress`).

Также поддерживается событие `readystatechange`, которое было описано ранее. Оно появилось гораздо раньше, ещё до появления текущего стандарта. От него можно отказаться в пользу современных событий, если учесть особенности IE8-9 (см. далее). 

## Особенности IE8,9: XDomainRequest

**В IE8 и IE9 поддержка `XMLHttpRequest` ограничена:**

<ul>
<li>Не поддерживаются события, кроме `onreadystatechange`.</li>
<li>Некорректно поддерживается состояние `readyState = 3`: браузер может сгенерировать его только один раз во время запроса, а не при каждом пакете данных. Кроме того, он не даёт доступ к ответу `responseText` до того, как он будет до конца получен.</li>
</ul>

Дело в том, что, когда создавались эти браузеры, спецификации были не до конца проработаны. Поэтому разработчики браузера решили добавить свой объект [XDomainRequest](/xhr-crossdomain) (только IE!), который реализовывал часть возможностей современного стандарта.

А обычный `XMLHttpRequest` решили не трогать, чтобы ненароком не сломать существующий код.

**Для того, чтобы получить некоторые из современных возможностей, вместо `new XMLHttpRequest()` пишем `new XDomainRequest`.**

Если кросс-браузерно:

```js
var XHR = window.XDomainRequest || XMLHttpRequest;
var xhr = new XHR();
```

Теперь в IE8,9 поддерживаются события `onload`, `onerror` и `onprogress`.

**Ещё одна деталь: IE9- по умолчанию кеширует ответы, не снабжённые антикеш-заголовком. Другие браузеры этого не делают.**

**Чтобы этого избежать, сервер должен добавить в ответ соответствующие антикеш-заголовки, например `Cache-Control: no-cache`.** 

По правде говоря, использовать заголовки типа `Expires`, `Last-Modified` и `Cache-Control` рекомендуется в любом случае, чтобы дать понять браузеру (не обязательно IE), что ему следует делать.

**Альтернативный вариант -- добавить в URL запроса случайный параметр, предотвращающий кеширование.**

Например, вместо `xhr.open('GET', 'service', false)` написать:

```js
xhr.open('GET', '*!*'service?r=' + Math.random()*/!*, false);
```

По историческим причинам такой способ предотвращения кеширования можно увидеть много где, так как старые браузеры плохо обрабатывали кеширующие заголовки. Сейчас серверные заголовки поддерживаются хорошо.

## Итого

Типовой код для GET-запроса при помощи `XMLHttpRequest`:

```js
var xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url', true);

xhr.onreadystatechange = function() {
  if (this.readyState != 4) return;

  // по окончании запроса доступны:
  // status, statusText
  // responseText, responseXML (при content-type: text/xml)

  if (this.status != 200) {
    // обработать ошибку
    alert('ошибка: ' + (this.status ? this.statusText || 'запрос не удался') );
    return;
  }

  // получить результат из this.responseText или this.responseXML
}

xhr.send();
```

Методы:

<ul>
<li>`open(method, url, async, user, password)`</li>
<li>`send(body)`</li>
<li>`abort()`</li>
<li>`setRequestHeader(name, value)`</li>
<li>`getResponseHeader(name)`</li>
<li>`getAllResponseHeaders()`</li>
</ul>

Свойства:

<ul>
<li>`timeout`</li>
<li>`responseText`</li>
<li>`responseXML`</li>
<li>`status`</li>
<li>`statusText`</li>
</ul>

События:

<ul>
<li>`onreadystatechange`</li>
<li>`ontimeout`</li>
<li>`onerror`</li>
<li>`onload`</li>
<li>`onprogress`</li>
<li>`onabort`</li>
<li>`onloadstart`</li>
<li>`onloadend`</li>
</ul>


[head]
<style>
.log-div {
  width: 600px;
  overflow: auto;
}
</style>
<script>
function voteSync(outputElem) {
  var xhr = new XMLHttpRequest(); // (1)

  outputElem.innerHTML = '...';

  xhr.open('GET', '/files/tutorial/ajax/xhr/vote', false); 
  xhr.send(null);   // (2)

  outputElem.innerHTML = xhr.responseText;  // (3)
}

function vote(outputElem) {
  var xhr = new XMLHttpRequest();

  xhr.open('GET', '/files/tutorial/ajax/xhr/vote', true);

  xhr.onreadystatechange = function() {
    if (xhr.readyState != 4) return;
    outputElem.innerHTML = xhr.responseText;
  }


  outputElem.innerHTML = '...';
  xhr.send(null);
}
</script>
[/head]