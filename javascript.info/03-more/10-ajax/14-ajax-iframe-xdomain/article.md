# IFRAME для кросс-доменных запросов

Современные браузеры поддерживают множество альтернатив ифреймам. В первую очередь, это современный [XMLHttpRequest](/ajax-xmlhttprequest), который может делать любые запросы, в том числе кросс-доменные и с пересылкой файлов.

А в IE6-9 ифреймы в некоторых ситуациях незаменимы, поэтому способ, описанный в этой статье, в первую очередь используется для поддержки этих браузеров.
Существует несколько вариантов реализации кросс-доменных запросов. Конкретный выбор зависит от версии IE, которую мы собираемся поддерживать.

## IE8+: postMessage-ответ

IE8 и выше поддерживают интерфейс [postMessage](https://developer.mozilla.org/en-US/docs/DOM/window.postMessage) для общения между окнами с разных доменов. 

Для его использования серверный код должен ответить на запрос примерно так:

```js
<script>
parent.postMessage(message, parentDomain);
</script>
```

Браузер проверит, действительно ли родительское окно `parent` с домена `parentDomain`, и если это так, то на нём будет вызвано событие `onmessage`, которое получит доступ к тексту `message`. 

В `message` должна содержаться информация о том, на какой запрос пришёл ответ, и  данные. Так как кросс-браузерно поддерживаются только сообщения-строки, то передать эту информацию можно через JSON.

Серверный код, который это делает:

```php
<?php 
header('Cache-Control: no-cache');
$data = json_encode($_POST['data'] ?: 'Server date: '.date('H:i:s'));
?>
<script>
*!*
parent.postMessage(JSON.stringify({
	name: window.name,
	body: <?=$data?>
}), "http://learn.javascript.ru"); 
*/!*
</script>
```

Код на клиенте, который будет реагировать на `postMessage`:

```js
window.onmessage = function(event) {
  // распаковать сообщение
  var message = JSON.parse(event.data);
  // вызвать обработку результата запроса
  CallbackRegistry[message.name](message.body);
}
```

Ещё одна небольшая тонкость -- время вызова `iframe.onload`. 

Задача этого обработчика -- проверить, всё ли вызвалось. Для этого он должен отработать обязательно *после* `onmessage`. А вызов `postMessage` -- асинхронный, поэтому нужно отложить проверку на `setTimeout(..,0)`.

При этом получится следующий поток выполнения:

<ol>
<li>Пришёл ответ с сервера, вызвал `postMessage`.</li>
<li>Событие `onmessage` встало в очередь выполнения.</li>
<li>Обработано окончание загрузки, вызвался `iframe.onload`, поставил в очередь проверку.</li>
<li>Сработает `onmessage`, а затем проверка.</li>
</ol>

Полный код кросс-доменного `iframeGet` (`iframePost` -- аналогично):

```js
//+ src="postmessage.js"
```

Пример в действии:

[iframe src="postmessage" border="1" link zip]

### postMessage-прокси

Если нужно часто обмениваться данными с одним доменом, то можно загрузить `iframe` с этого домена, содержащий код `postMessage` и `onmessage`:

```html
<script>
window.onmessage = function(event) {
  // получил информацию с основной страницы

  if (event.origin != 'javascript.ru') return; // обратились с чужого сайта

  // послать event.data на свой домен
  // по окончании запроса вызвать parent.postMessage(ответ, ...)
}
</script>
```

Время от времени этому `iframe` пересылаются сообщения, он обменивается информацией со своей страницей (можно через `XMLHttpRequest`) и отвечает основной странице.

При этом ифрейм будет только один, пересоздавать ничего не нужно.


## IE6: передача через window.name

Этот способ активно используется, так как с одной стороны покрывает ряд важных сценариев использования, а с другой -- поддерживается всеми браузерами, включая IE6+.

У `IFRAME` есть атрибут `name`, который задаёт "имя окна". Обычно он используется для отправки форм в данный ифрейм или для доступа к внутреннему окну через `window.frames[name]`.

Но можно и использовать его для другой, непредусмотренной цели -- передачи данных.

Дело в том, что имя окна не меняется при навигации в `IFRAME`, и при этом доступно из JavaScript. Поэтому если одна страница поставила `window.name = "Вася"`, а потом посетитель нажал на ссылку в `IFRAME` и перешёл на другую страницу (домен не важен), то она сможет прочитать "Вася" из `window.name`. 

Это делает возможным следующий алгоритм:

<ol>
<li>Страница на основном домене создаёт `IFRAME` и отправляет в него запрос *на другой домен*.</li>
<li>Сервер отвечает кодом, который выглядит примерно так:

```php
<?php ... ?>
<script>
window.name = "данные"; 

// IFRAME сам должен поменять свой адрес, иначе в IE name не сохранится
// blank.html - любой пустой документ на основном домене
window.location.replace('http://основной домен/blank.html');
</script>
```

</li>
<li>Страница по `iframe.onload` читает `iframe.contentWindow.name` и получает данные.</li>
</ol>

Ниже реализован метод POST, т.к. кросс-доменный GET можно сделать и при помощи [Транспорта SCRIPT](/ajax-jsonp):

```js
//+ src="name.js"
```

Обратите внимание на комментарии, они более подробно описывают важные детали коммуникации.

Пример в действии:

[iframe src="name" border="1" zip link]

### Сфера использования

У метода `window.name` почти нет недостатков.

<ul>
<li>Он работает во всех браузерах.</li>
<li>Он прост в реализации.</li>
<li>В `window.name` кросс-браузерно влезает до 2МБ.</li>
<li>Пустой документ `blank.html` будет сразу же закэширован браузером, и в дальнейшем лишнего запроса не будет.</li>
</ul> 

Единственное ограничение -- ответ до 2МБ. Многие сценарии использования, например кросс-доменная авторизация, легко вписываются в них.

## IE6+: hash-прокси

Этот способ представляет собой отвратительнейший хак. Он заключается в том, что при общении между основной страницей и ифреймом с другого домена -- они могут легко менять `hash` друг другу (часть пути после `#`).

Считается, что это безопасно, т.к. изменение хэша -- всего лишь прыжок по странице, поэтому браузеры это разрешают.

При этом читать хэши друг друга нельзя, можно только писать в них.

Соответственно, логика взаимодействия такая:

<ol>
<li>Главная страница подключает ифрейм с другого домена.</li>
<li>Ифрейму меняется `hash`, он видит это и понимает, что ему "хотят что-то этим сказать", обрабатывает полученное сообщение.</li>
<li>Когда ифрейм готов, он, в свою очередь, меняет хэш родителю. Тот принимает ответ.</li>
</ol>

При этом у родителя и ифрейма существует протокол общения через хэш. Ограничение -- не более 4kb (минус длина базовой части URL) на сообщение.

Обход проблем:
<ul>
<li>**При такой реализации на п.3 окно-родитель будет "прыгать" -- ему же меняют хэш!**

Поэтому в реальности используют три ифрейма: родительское окно `main` включает ифрейм с того же домена `localProxy.html`, а уже он включает в себя ифрейм с другого домена `remoteProxy.html`.

Общение осуществляется по цепочке `main -> localProxy -> remoteProxy -> localProxy -> main`. Хэш меняется у промежуточного прокси, который сообщает об этом родительскому окну (он на одном домене с ним).

Можно сделать фреймы `localProxy` и `remoteProxy` на одном уровне. Тогда не во всех браузерах будет работать (в Opera не будет?), но в IE всё (вроде!) будет ок.</li
<li>**Как окну(или ифрейму) обнаружить изменение хэща?** 

В старых браузерах отсутствует событие `onhashchange`, поэтому используются два подхода:
<ol>
<li>Окно раз в 50мс проверяет, поменялся ли хэш.</li>
<li>Используется `window.onresize` как сигнал: когда ифрейму меняем хэш -- тут же немного изменим и его размер, на нём сработает событие `onresize`.</li>
</ol>
</li>
</ul>

Автор этих строк реализовывал такой протокол в очень бородатые времена, несколько раз участвовал в обсуждениях проектов, использующих такое решение -- и всегда был удивлён, насколько стабильно оно работает. Несмотря на хакерскую природу самого решения.

В этом случае ифрейм перегружать не надо, поэтому большей частью такой подход используется даже не для AJAX, а для общения между постоянно встроенным виджетом-ифреймом и основной страницей.

Область применения -- когда обязательна поддержка IE6,7 и никакие другие способы, почему-то, не подходят.


[head]
<script src="/files/tutorial/ajax/script/scriptRequest.js"></script>
[/head]