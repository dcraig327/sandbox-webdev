# Ограничение "Same Origin"

Ограничение "Same Origin" ("тот же источник") ограничивает доступ окон и фреймов друг к другу, а также влияет на AJAX-запросы к серверу.

Причина, по которой оно существует -- безопасность. Если есть два окна, в одном из которых `vasya-pupkin.com`, а в другом `gmail.com`, то мы бы не хотели, чтобы скрипт из первого мог читать нашу почту.

Сама концепция проста, но есть много важных исключений и особенностей, которые нужно знать для полного понимания этого правила.
[cut]

## Same Origin [[#same-origin]

[summary]
Два URL считаются имеющим один источник ("same origin"), если у них одинаковый протокол, домен и порт.
[/summary]

Эти URL имеют один источник:
<ul>
<li>`http://site.com`</li>
<li>`http://site.com`/</li>
<li>`http://site.com/my/page.html`</li>
</ul>

А вот эти -- все из других источников:
<ul>
<li>http://<span style="color:red">www.</span>site.com (другой домен)</li>
<li>http://site.<span style="color:red">org</span>  (другой домен)</li>
<li>http<span style="color:red">s</span>://site.com  (другой протокол)</li>
<li>http://site.com<span style="color:red">:8080</span>  (другой порт)</li>
</ul>

Существует ряд исключений, позволяющих-таки окнам с разных доменов обмениваться информацией, но прямой вызов методов друг друга и чтение свойств запрещены.

## Пример ограничений

**Если одно окно попытается обратиться к другому, то браузер проверит, из одного ли они источника. Если нет -- доступ будет запрещён.**

Например:

```html
<!--+ run -->
<iframe src="http://vk.com" name="vk" style="height:100px"></iframe>

<script> 
  var iframe = document.getElementsByName('vk')[0];
  iframe.onload = function() {
    try {
      alert(iframe.contentWindow.document);
    } catch(e) {
      alert("Ошибка: " + e.message);
    }
  }
</script>
```

**При запуске примера выше Safari/Chrome могут вместо ошибки вывести `undefined`.** 

Это их способ (некорректный) показать, что "чтение запрещено". Будем надеяться, исправят.



## Исключение: запись в location

**Окно и вложенный в него `iframe` могут менять `location` друг друга, даже если они из разных источников.**

Причём *читать* `location` нельзя, одно окно не имеет право знать, на каком URL пользователь в другом. А вот *запись* браузеры считают безопасной.

Например, открыв на `javascript.ru` ифрейм с `vk.com`, из этого ифрейма нельзя будет узнать URL, а вот поменять его -- запросто:

```html
<!--+ run -->
<iframe src="http://vk.com" name="vk"></iframe>
 
<script>
  var iframe = document.getElementsByName('vk')[0];
    
  iframe.onload = function () {

    try { // попытка чтения
*!*
      alert(iframe.contentWindow.location.href); // неудачно
*/!*
    } catch(e) {
      alert('Ошибка: ' + e.message);
    }

    try { // запись в location будет успешной
*!*
     iframe.contentWindow.location = 'http://wikipedia.org';
*/!*
     alert('Перенаправили на http://wikipedia.org');
    }

  };
</script>
```

## Исключение: поддомен 3го уровня

Ещё одно важное исключение касается доменов третьего уровня.

Например, у нас есть окно на `http://site.com` и два ифрейма: первый с источника `http://john.site.com`, а второй -- с `http://peter.site.com`.

**Если несколько окон присваивают в `document.domain` свой общий поддомен 2го уровня, то все ограничения снимаются.**

Важно:
<ol>
<li>Должен быть общий поддомен второго уровня. 

Можно поставить `document.domain='site.com'` на странице с `my.site.com`, но нельзя это сделать на странице с `vaysa-pupkin.ru`.</li>
<li>Свойство `document.domain` должно быть присвоено на всех окнах, участвующих в коммуникации, в том числе на том, которое и так с этого домена.

Выглядит абсурдно, но на документе с `site.com` нужно вызвать: `document.domain=document.domain`. Тогда будет работать.</li>
</ol>


## Исключение: порт в IE

В браузере Internet Explorer порт не входит в понятие "источник" (origin).

Это означает, что окно с `http://site.com` может свободно общаться с `http://site.com:8080`. 

Это иногда используют для общения разных сервисов, использующих один IP-адрес. Но допустимо такое только в IE.

## Исключение: зона в IE

Если сайт находится в зоне "Надёжные узлы", то в Internet Explorer ограничения к нему не применяются.

При этом подразумевается, что для этой зоны в параметрах "Безопасность" включена опция "Доступ к источникам данных за пределами домена".

## Общение между окнами с разных источников

Если ни одно из исключений выше не подошло, то есть три основных способа, как окнам общаться между собой:

<ol>
<li>Все современные браузеры, включая IE8+, поддерживают специальный интерфейс `postMessage` для общения между окнами с разных доменов. Мы рассмотрим его в отдельной главе [](/cross-window-messaging-with-postmessage).</li>
<li>Одно окно может поменять другому `location.hash` -- часть пути после `#`. При этом не произойдёт смены `URL`, но другое окно, увидев это, может прочитать из хэша информацию и, в свою очередь, ответить.

Этот способ испольуется там, где требуется поддержка IE<8. 
</li>
</ol>

В совокупности с этим можно использовать интерфейс `localStorage` для оповещении всех окон и вкладок о событии. При сохранении данных в `localStorage` генерируется событие `onstorage`, причём сразу на всех окнах, фреймах и табах с тем же доменом.

Кроме того, если вы используете `IFRAME` вместе с AJAX, то, возможно, вам пригодятся способы, описанные в главе [](/ajax-iframe-xdomain).



## Итого

Ограничение "одного источника" запрещает окнам и фреймам с разных источников вызывать методы друг друга и читать данные друг из друга.

При этом "из одного источника" означает "совпадают протокол, домен и порт".

Как ни странно, у этого подхода ряд существенных исключений:

<ul>
<li>Свойство `window.location` нельзя читать, но можно менять.</li>
<li>Домены третьего уровня с общим наддоменом могут поменять `document.domain` на их общий домен второго уровня, и тогда они смогут взаимодействовать без ограничений.
</li>
<li>IE не включает порт в понятие источника. Кроме того, он позволяет снять ограничения для конкретного сайта включением в доверенную зону.</li>
</ul>

В современных браузерах (IE8+) кросс-доменное общение можно организовать через `location.hash` и [postMessage](/cross-window-messaging-with-postmessage). При этом IE8 не умеет передавать данные между окнами, но, если нужно, `localStorage` передаёт всё и везде :)