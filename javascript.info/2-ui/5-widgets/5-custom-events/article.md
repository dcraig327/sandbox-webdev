# Коллбэки и события на компонентах

Компоненты, хоть и каждый сам по себе, обычно интегрированы друг с другом. 

Есть несколько способов, при помощи которых компоненты сообщают друг другу о важных событиях, которые в них произошли.

[cut]

## Коллбэки

Коллбэк (от англ. callback) -- это функция, которую мы передаём куда-либо и ожидаем, что она будет вызвана при наступлении события.

Например, мы можем добавить в `options` для `Menu` новый параметр -- функцию `onselect`, которая будет вызываться при выборе пункта меню:

```js
var menu = new Menu({ 
  title: "Сладости",
  template: _.template($('#menu-template').html()),
  listTemplate: _.template($('#menu-list-template').html()),
  items: {
    "donut": "Пончик", 
    "cake": "Пирожное", 
    "chocolate": "Шоколадка"
  },
*!*
  onselect: showSelected
*/!*
});

*!*
function showSelected(href) {
  alert(href);
}
*/!*
```

В коде меню нужно будет вызывать её, как-то так:

```js
...
  function onItemClick(e) {
    e.preventDefault();
*!*
    var onselect = options.onselect;
    if (onselect) {
      onselect(e.currentTarget.getAttribute('href').slice(1));
    }
*/!*
  }
...
```

Демо:

[example src="menu-callback" height="180"]

## Свои события 

Оповещение через коллбэки -- это примерный аналог назначения обработчика через `onсвойство` для DOM-элементов. 

Да, он работает, но чтобы можно было назначать сколько угодно обработчиков в любой момент, нужна полноценная поддержка событий, то есть аналог `addEventListener`.

Поддержка событий для компонентов будет выглядеть так:

```js
var menu = new Menu(...);

// любой код может подписаться на событие "select"
menu.on("select", function(item) {
  // при выборе пункта меню сработает этот обработчик
  alert("Выбран элемент " + item);
});
```

Код, который заинтересован в том, чтобы узнавать, что происходит с меню, подписывается на нужные события вызовом `menu.on(имя события, обработчик)`.

Далее `Menu` при наступлении события вызывает обработчик методом `trigger`, при необходимости передавая ему важные данные в качестве аргументов, вот так:

```js
function Menu(options) {
  var self = this;

*!*
  // ... при клике на item - сгенерировать событие (trigger)
  function onItemClick(e) {
    e.preventDefault();
    
    self.trigger("select", e.currentTarget.getAttribute('href').slice(1));
  }
*/!*    

}
```

Обратим внимание -- события будут генерироваться не на элементе `<div class="menu">`, а на объекте `new Menu`. Сейчас мы разберём методы, которые для этого нужны.

## Методы on, off и trigger

Для поддержки событий в любой объект достаточно добавить три метода: `on`, `off` и `trigger`, которые перечислены ниже в свойствах `EventMixin`:

```js
var EventMixin = {

  /**
   * Подписка на событие
   * Использование:
   *  menu.on('select', function(item) { ... }
  */
  on: function(eventName, handler) {
    if (!this._eventHandlers) this._eventHandlers = {};
    if (!this._eventHandlers[eventName]) {
      this._eventHandlers[eventName] = [];
    }
    this._eventHandlers[eventName].push(handler);
  },

  /**
   * Прекращение подписки
   *  menu.off('select',  handler)
   */
  off: function(eventName, handler) {
    var handlers = this._eventHandlers && this._eventHandlers[eventName];
    if (!handlers) return;
    for(var i=0; i<handlers.length; i++) {
      if (handlers[i] == handler) {
        handlers.splice(i--, 1);
      }
    }
  },

  /**
   * Генерация события с передачей данных
   *  this.trigger('select', item);
   */
  trigger: function(eventName) {

    if (!this._eventHandlers || !this._eventHandlers[eventName]) {
      return; // обработчиков для события нет
    }

    // вызвать обработчики 
    var handlers = this._eventHandlers[eventName];
    for (var i = 0; i < handlers.length; i++) {
      handlers[i].apply(this, [].slice.call(arguments, 1));
    }

  }
};
```

Объект `EventMixin` -- всего лишь хранилище для функций, которые нужно скопировать в тот объект, которому нужны события.

Пример использования:

```js
//+ run
var obj = {}; // произвольный объект

*!*
// скопируем в него методы для работы с событиями
*/!*
for(var m in EventMixin) obj[m] = EventMixin[m];

*!*
// поставить обработчик на событие hello
*/!*
obj.on("hello", function(a, b, c) {
  alert(a + ", " + b + ", " + c);
});

// и ещё один обработчик
obj.on("hello", function() {
  alert("привет!");
});

*!*
// генерация события с дополнительными данными
// обычно происходит внутри методов объекта
*/!*
obj.trigger("hello", "data1", "data2", "data3");
```

При запуске этого кода будет поставлено два обработчика на событие `hello`, которые (по очереди) будут вызваны при `obj.trigger(...)`.

[smart header="Внутренний алгоритм `on/off/trigger`"]
Большинство фреймворков, предоставляющих события на произвольных объектах, работают примерно так же, как `on/off/trigger` в примере выше.

**Все обработчики событий `obj` хранятся в "скрытом" свойстве самого `obj`.**
<ul>
<li>Вызов `obj.on(event, handler)` создаёт свойство `obj._eventHandlers`, если его ещё нет, и сохраняет в нём обработчик: `obj._eventHandlers[event].push(handler)`.</li>
<li>Далее вызов `obj.trigger(event, ...)` получает обработчики из `obj._eventHandlers[event]` и выполняет их один за другим.</li>
<li>Вызов `obj.off(event, handler)` удаляет обработчик из `obj._eventHandlers`.</li>
</ul>
[/smart]

## Меню с событиями

Для перехода на события в меню, нужно:
<ol>
<li>Добавить методы из `EventMixin` в объект меню. Их можно скопировать либо в объект, либо в прототип.</li>
<li>Вместо вызова коллбэка `onselect` -- генерируем событие вызовом `trigger('select', значение)`.</li>
</ol>

Код:

```js
function Menu(options) {
  var elem;
  var self = this;

*!*
  for(var method in EventMixin) {
    this[method] = EventMixin[method]
  }
*/!*

  function onItemClick(e) {
    e.preventDefault();

*!*
    self.trigger("select", currentTarget.getAttribute('href').slice(1));
*/!*
  }
  
  // другие методы без изменений
}
```

Во внешнем коде:

```js
var menu = new Menu(...)
menu.on('select', function(value) { 
  alert('выбрано значение ' + value);
});
```

Результат:
[example src="menu-event"]

## События при помощи jQuery

Фреймворк jQuery предоставляет свои средства для генерации произвольных событий.

Метод [trigger](http://api.jquery.com/trigger/) позволяет генерировать любое событие на элементе и он же -- работает на любом объекте, "обёрнутом" в jQuery: `$(...)`.

Синтаксис для генерации события на элементе:

```js
elem.trigger(event);
```

Объект `event` должен содержать свойство `type` -- тип события (произвольный) и любые другие свойства, которые будут переданы обработчикам.

Например:

```js
$('body').on('hello', function(e) { 
  alert(e.user) 
});

*!*
$('body').trigger({ 
  type: 'hello', // тип события
  user: 'Вася', // любые данные
});
*/!*

$('body').off('hello');
```

Есть также альтернативный синтаксис:

```js
elem.trigger(eventType, args);
```

<ul>
<li>`eventType` -- тип события (строка)</li>
<li>`args` -- массив аргументов, которые будут переданы обработчику.</li>
</ul>

Пример использования:

```js
$('body').on('hello', function(e, user) { 
  alert(user) 
});

*!*
// аргументы - в виде массива 
$('body').trigger("hello", ["Вася"]);
*/!*

$('body').off('hello');
```

Как правильно, предпочтителен первый синтаксис: `elem.trigger(event)`, поскольку он гораздо гибче, можно указывать любые свойства в любом порядке.

События, сгенерированные таким образом на элементах, всплывают и обрабатываются jQuery наравне с обычными браузерными событиями.

**Для объекта всё точно так же, как и для элемента:**

```js
//+ run
var obj = {}; // произвольный объект 

$(obj).on('hello', function(e) { 
  alert(e.user) 
});

$(obj).trigger({
  type: 'hello',
  user: 'Вася'
});
```

Конечно, события на объектах не всплывают, всё-таки "всплытие" -- это привилегия DOM.

Внутри jQuery делает в точности то же самое, что `EventMixin` -- вызов `on(...)` добавляет обработчик добавляются в "скрытое" свойство объекта, из которого они потом читаются и выполняются вызовом `trigger(...)`.

Это свойство можно легко увидеть:

```js
//+ run
var obj = {};

$(obj).on('hello', function(e) { /* ... */ });

// свойство называется примерно так: jQuery19105266267273109406
// оно имеет такое псевдослучайное название, 
// чтобы не перезаписать "настоящие", важные свойства объекта
for(var prop in obj) alert(prop);
```

Технически, можно генерировать событие и на корневом элементе меню `<div class="menu">` и на JavaScript-объекте `new Menu` (`this` внутри конструктора). Однако, обычно используют именно объект: считается, что DOM компонента -- это его сугубо личное дело. Он может в любой момент поменяться и быть пересоздан "с нуля", если потребуется. Залезать в него снаружи и ставить какие-то обработчики никто не имеет права.


## Итого

Для того, чтобы внешний код мог узнавать о важных событиях, произошедших внутри компоненты, используются:
<ul>
<li>Коллбэки -- функции, которые передаются "снаружи" при создании компонента, и которые он обязуется вызвать при наступлении событий.</li>
<li>События -- компонент генерирует их при помощи вызова `trigger` (`EventMixin`, jQuery или другой фреймворк), а внешний код ставит обработчики при помощи `on`.</li>
</ul>

Можно использовать и то и другое одновременно. Например, виджеты фреймворка jQuery UI позволяют передать при создании коллбэк `onselect`, и вместе с тем генерируют событие. 

Далее, для простоты, в примерах и задачах мы будем использовать для событий методы `on/off/trigger` из jQuery. Если jQuery не нужен -- всегда можно использовать `EventMixin` или какой-либо другой фреймворк.


[libs]
event-mixin.js
[/libs]