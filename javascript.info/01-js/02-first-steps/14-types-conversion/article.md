# Преобразование типов для примитивов

Система преобразования типов в JavaScript очень проста, но отличается от других языков. Поэтому она часто служит "камнем преткновения" для приходящих из других языков программистов.
[cut]
Всего есть три преобразования:
<ol>
<li>Cтроковое преобразование.</li>
<li>Числовое преобразование.</li>
<li>Преобразование к логическому значению.</li>
</ol>

**Эта глава описывает преобразование только примитивных значений, объекты разбираются далее в учебнике.**


## Строковое преобразование   

Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция `alert`.

```js
//+ run
var a = true;

alert(a); // "true"
```

Можно также осуществить преобразование явным вызовом `String(val)`:

```js
//+ run
alert( String(null) === "null" ); // true
```

Также для явного преобразования применяется оператор `"+"`, у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:

```js
//+ run
alert( true + "test" ); // "truetest"
alert( "123" + undefined); // "123undefined"
```

## Численное преобразование   

Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений `===`, `!==`).

Для преобразования к числу в явном виде можно вызвать `Number(val)`, либо, что короче, поставить перед выражением оператор унарный плюс `"+"`:

```js
var a = +"123"; // 123
var a = Number("123"); // 123, тот же эффект
```

<table class="bordered">
<tr><th>Значение</th><th>Преобразуется в...</th></tr>
<tr><td>`undefined`</td><td>`NaN`</td></tr>
<tr><td>`null`</td><td>`0`</td></tr>
<tr><td>`true / false`</td><td>`1 / 0`</td></tr>
<tr><td>Строка</td><td>Пробельные символы по краям обрезаются.<br>Далее, если остаётся пустая строка, то `0`.<br>Из непустой строки "считывается" число, при ошибке результат: `NaN`.</td></tr>
</table>

Например:

```js
//+ run
alert( +"   \n  123   \n  \n"); // 123
```

Ещё примеры:
<ul>
<li>Логические значения:

```js
//+ run
alert( +true ); // 1
alert( +false); // 0
```

</li>
<li>Сравнение разных типов -- значит численное преобразование:

```js
//+ run
alert( "\n0\n" == 0 ); // true
```

При этом строка `"\n0\n"` преобразуется к числу -- начальные и конечные пробелы игнорируются, получается `0`.</li>
</li>
<li>
Ещё пример сравнения разных типов:

```js
//+ run
alert( "\n" == false );
alert( "1" == true );
```

Здесь сравнение `"=="` снова приводит обе части к числу. В первой строке слева и справа получается `0`, во второй `1`.
</li>
</ul>

### Специальные значения

Посмотрим на поведение специальных значений более внимательно.

**Интуитивно, значения `null/undefined` ассоциируются с нулём, но при преобразованиях ведут себя иначе.**

Специальные значения преобразуются к числу так:
<table class="bordered">
<tr><th>Значение</th><th>Преобразуется в...</th></tr>
<tr><td>`undefined`</td><td>`NaN`</td></tr>
<tr><td>`null`</td><td>`0`</td></tr>
</table>

Это преобразование осуществляется при арифметических операциях и сравнениях `> >= < <=`, но не при проверке равенства `==`. Алгоритм проверки равенства для этих значений в спецификации прописан отдельно (пункт [11.9.3](http://es5.github.com/x11.html#x11.9.3)). В нём считается, что `null` и `undefined` равны `"=="` между собой, но эти значения не равны никакому другому значению.

Это ведёт к забавным последствиям. 

Например, `null` не подчиняется законам математики -- он "больше либо равен нулю": `null>=0`, но не больше и не равен:

```js
//+ run
alert(null >= 0); // true, т.к. null преобразуется к 0
alert(null > 0); // false (не больше), т.к. null преобразуется к 0
alert(null == 0 ); // false (и не равен!), т.к. == рассматривает null особо.
```

Значение `undefined` вообще вне сравнений:

```js
//+ run
alert(undefined > 0); // false, т.к. undefined -> NaN
alert(undefined == 0); // false, т.к. это undefined (без преобразования)
alert(undefined < 0); // false, т.к. undefined -> NaN
```

**Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях `> >= < <=`.** 

Используйте в таких случаях переменные-числа или приводите к числу явно.
 
## Логическое преобразование

**Преобразование к `true/false` происходит в логическом контексте, таком как `if(obj)`, `while(obj)` и при применении логических операторов.**

Все значения, которые интуитивно "пусты", становятся `false`. Их несколько: `0`, пустая строка, `null`, `undefined` и `NaN`. 

Остальное, в том числе и любые объекты -- `true`.

Полная таблица преобразований:

<table class="bordered">
<tr><th>Значение</th><th>Преобразуется в...</th></tr>
<tr><td>`undefined`, `null`</td><td>`false`</td></tr>
<tr><td>Числа</td><td>Все `true`, кроме `0`, `NaN` -- `false`.</td></tr>
<tr><td>Строки</td><td>Все `true`, кроме пустой строки `""` -- `false`</td></tr>
<tr><td>Объекты</td><td>Всегда `true`</td></tr>
</table>

**Для явного преобразования используется двойное логическое отрицание `!!value` или вызов `Boolean(value)`.**

[warn header="Обратите внимание: строка `\"0\"` становится `true`"]
В отличие от многих языков программирования (например PHP), `"0"` в JavaScript является `true`, как и строка из пробелов:

```js
//+ run
alert( !!"0" ); // true
alert( !!" " ); // любые непустые строки, даже из пробелов - true!
```

[/warn]


Логическое преобразование интересно тем, как оно сочетается с численным.

**Два значения могут быть равны, но одно из них в логическом контексте `true`, другое -- `false`**.

Например, равенства в следующем примере верны, так как происходит численное преобразование:

```js
//+ run
alert( 0 == "\n0\n" );  // true
alert( false == " " ); // true
```

...А в логическом контексте левая часть даст `false`, правая -- `true`:

```js
//+ run
if ("\n0\n") { 
  alert("true, совсем не как 0!");
}
```

С точки зрения преобразования типов в JavaScript это совершенно нормально. При равенстве -- численное преобразование, а в `if` -- логическое, только и всего.

## Итого

**В JavaScript есть три преобразования:**

<ol>
<li>Строковое: `String(value)` -- в строковом контексте или при сложении со строкой</li>
<li>Численное: `Number(value)` -- в численном контексте, включая унарный плюс `+value`.</li>
<li>Логическое: `Boolean(value)` -- в логическом контексте, можно также сделать двойным НЕ: `!!value`.</li>
</ol>

**Сравнение не осуществляет преобразование типов в следующих случаях:**
<ul>
<li>При сравнении объектов. Две переменные, которые являются объектами равны только, когда ссылаются на один и тот же объект.</li>
<li>При сравнении двух строк. Там отдельный алгоритм сравнения. А вот если хоть один операнд -- не строка, то значения будут приведены: `true > "000"` станет `1 > 0`.</li>
<li>При проверке равенства с `null` и `undefined`. Они равны друг другу, но не равны чему бы то ни было ещё, этот случай прописан особо в спецификации.</li>
</ul>

