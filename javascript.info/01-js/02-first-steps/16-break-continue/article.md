# Директивы break и continue

Для более гибкого управления циклом используются директивы `break` и `continue`.
[cut]
## Выход: break   

Выйти из цикла можно не только при проверке условия но и, вообще, в любой момент. Эту возможность обеспечивает директива `break`.

Например, бесконечный цикл в примере прекратит выполнение при `i==5`:

```js
var i=0;

while(1) {
  i++;   

  *!*if (i==5) break;*/!*

  alert(i);
}

alert('Последняя i = '+ i ); // 5 (*)
```

Выполнение продолжится со строки `(*)`, следующей за циклом.

## Следующая итерация: continue [#continue]

Директива `continue` прекращает выполнение *текущей итерации* цикла. Например, цикл ниже не выводит четные значения:

```js
//+ run
for (var i = 0; i < 10; i++) {
  
  *!*if (i % 2 == 0) continue;*/!*

  alert(i);
}
```

Для четных `i` срабатывает `continue`, выполнение блока прекращается и управление передается на `for`.

[smart header="Совет по стилю"]

Как правило, `continue` и используют, чтобы не обрабатывать определенные значения в цикле. 

Цикл, который обрабатывает только часть значений, мог бы выглядеть так:

```js
for (var i = 0; i < 10; i++) {
  
  if ( checkValue(i) ) { 
    // функция checkValue проверяет, подходит ли i

    // ...
    // ... обработка
    // ... этого
    // ... значения
    // ... цикла
    // ...

  }
}
```

Все хорошо, но мы получили *дополнительный уровень вложенности фигурных скобок, без которого можно и нужно обойтись*. 

Гораздо лучше здесь использовать `continue`:

```js
for (var i = 0; i < 10; i++) {
  
  *!*if ( !checkValue(i) ) continue;*/!*
 
  // здесь мы точно знаем, что i подходит

  // ...
  // ... обработка
  // ... этого
  // ... значения
  // ... цикла
  // ...

}
```

[/smart]

[warn header="Нельзя использовать break/continue справа от оператора '?'"]
Обычно мы можем заменить `if` на оператор вопросительный знак `'?'`.

То есть, запись:

```js
if (условие) {
  a();
} else {
  b();
}
```

..Аналогична записи:

```js
условие ? a() : b();
```

В обоих случаях в зависимости от условия выполняется либо `a()` либо `b()`.

Но разница состоит в том, что оператор вопросительный знак `'?'`, использованный во второй записи, возвращает значение. 

**Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе `'?'`.** К таким относятся большинство конструкций и, в частности, `break/continue`.

Поэтому такой код приведёт к ошибке:

```js
(i > 5) ? alert(i) : *!*continue*/!*;
```

[/warn]

## Метки

Бывает нужно выйти одновременно из нескольких уровней цикла.

Представим, что нужно ввести значения точек. У каждой точки есть две координаты `(i, j)`. Цикл для ввода значений `i,j = 0..2` может выглядеть так:

```js
//+ run
for (var i = 0; i < 3; i++) {

  for (var j = 0; j < 3; j++) {
    
    var input = prompt("Значение в координатах " + i + "," + j, "");

    if (input == null) *!*break*/!*; // (*)

  }
}
alert('Готово!');
```

Здесь `break` используется, чтобы прервать ввод, если посетитель нажал на `Отмена`. Но обычный вызов `break` в строке `(*)` не может прервать два цикла сразу. Как же прервать ввод полностью? Один из способов -- поставить *метку*.

Метка имеет вид `"имя:"`, имя должно быть уникальным. Она ставится перед циклом, вот так:

```js
outer: for (var i = 0; i < 3; i++) { ... }
```

Можно также выносить ее на отдельную строку. Вызов `break outer` прерывает управление цикла с такой меткой, вот так:

```js
//+ run
outer:
for (var i = 0; i < 3; i++) {

  for (var j = 0; j < 3; j++) {
    
    var input = prompt('Значение в координатах '+i+','+j, '');

    if (input == null) *!*break outer*/!*; // (*)

  }
}
alert('Готово!');
```

Директива `continue` также может быть использована с меткой. Управление перепрыгнет на следующую итерацию цикла с меткой.

**Метки можно ставить в том числе на блок, без цикла:**

```js
//+ run
my: {

  for (;;) {
    for (i=0; i<10; i++) {
      if (i>4) break my;
    }
  }
  
  some_code; // произвольный участок кода

}
alert("После my"); // (*)
```

В примере выше, `break` перепрыгнет через `some_code`, выполнение продолжится сразу после блока `my`, со строки `(*)`. Возможность ставить метку на блоке используется редко. Обычно метки ставятся перед циклом. 

[smart header="Goto?"]
В некоторых языках программирования есть оператор `goto`, который может передавать управление на любой участок программы. 

Операторы `break/continue` более ограниченны. Они работают только внутри циклов, и метка должна быть не где угодно, а выше по уровню вложенности.

В JavaScript нет `goto`.
[/smart]

