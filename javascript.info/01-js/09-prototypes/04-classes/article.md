# Свои классы на прототипах

Используем ту же структуру, что JavaScript использует внутри себя, для объявления своих классов.

[cut]
## Обычный конструктор

Вспомним, как мы объявляли конструкторы ранее.

Например, этот код задаёт объект `Animal` без всяких прототипов:

```js
//+ run
function Animal(name) {
  this.speed = 0;
  this.name = name;
 
  this.run = function(speed) {
    this.speed += speed;
    alert(this.name + ' бежит, скорость ' + this.speed);
  };

  this.stop = function() {
    this.speed = 0;
    alert(this.name + ' стоит');
  };
};

var animal = new Animal('Зверь');

alert(animal.speed);               // 0, начальная скорость
animal.run(3);                     // Зверь бежит, скорость 3
animal.run(10);                    // Зверь бежит, скорость 13
animal.stop();                     // Зверь стоит
```

## Класс через прототип

А теперь создадим аналогичный класс, используя прототипы, наподобие того, как сделаны классы `Object`, `Date` и остальные.

**Чтобы объявить свой класс, нужно:**
<ol>
<li>Объявить функцию-конструктор.</li>
<li>Записать методы и свойства, нужные всем объектам класса, в `prototype`.</li>
</ol>

Опишем класс `Animal`:

```js
//+ run
// конструктор
function Animal(name) {
  this.name = name;
}

// методы в прототипе
Animal.prototype.run = function(speed) {
  this.speed += speed;
  alert(this.name + ' бежит, скорость ' + this.speed);
};

Animal.prototype.stop = function() {
  this.speed = 0;
  alert(this.name + ' стоит');
};

// свойство speed со значением "по умолчанию"
Animal.prototype.speed = 0;

var animal = new Animal('Зверь');

alert(animal.speed);               // 0, свойство взято из прототипа
animal.run(5);                     // Зверь бежит, скорость 5
animal.run(5);                     // Зверь бежит, скорость 10
animal.stop();                     // Зверь стоит
```

Здесь объекту `animal` принадлежит лишь свойство `name`, а остальное находится в прототипе.

Обратим внимание, значение `speed` по умолчанию тоже перенесено в прототип, ведь оно во всех объектах (в начале) одинаково, но вызовы `animal.run()`, `animal.stop()` в примере используют вызов `this.speed += speed`, а любая запись в `this.свойство` работает с самим объектом.

То есть, начальное значение `speed` берётся из прототипа, а новое -- пишется уже в сам объект. И в дальнейшем используется.

<img src="7.png">

## Сравнение

Чем такое задание класса лучше и хуже предыдущего?

[compare]
+Прототип позволяет хранить общие свойства и методы в единственном экземпляре, таким образом экономится память и создание объекта происходит быстрее, чем если записывать их в каждый `this`.
-При объявлении класса через прототип, мы теряем возможность использовать локальные переменные и функции.
[/compare]

К примеру, есть у нас приватное свойство `name` и метод `sayHi` в функциональном стиле ООП:

```js
//+ run
function Animal(name) {
  this.sayHi = function() {
*!*
    alert(name);
*/!*
  };
}

var animal = new Animal("Зверь");
animal.sayHi(); // Зверь
```

При задании методов в прототипе мы не сможем её так оставить, ведь методы находятся *вне* конструктора, у них нет общей области видимости, поэтому приходится записывать `name` в сам объект, обозначив его как защищённое:

```js
//+ run
function Animal(name) {
*!*
  this._name = name;
*/!*
}

Animal.prototype.sayHi = function() {
*!*
  alert(this._name);
*/!*
}

var animal = new Animal("Зверь");
animal.sayHi(); // Зверь
```

Ранее в каждый объект `Animal` записывалась своя функция `this.sayHi`, а теперь есть одна функция такого рода в прототипе. В сам объект мы пишем только то, что свойственно именно этому объекту.

## Задачи


**Обычно свойства по умолчанию хранятся в прототипе. Но если свойство по умолчанию -- объект, то его в прототипе хранить нельзя.** 

Почему? Смотрите задачу ниже на эту тему.

