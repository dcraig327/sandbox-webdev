# Свойство F.prototype и создание объектов через new

До этого момента мы говорили о наследовании объектов, объявленных через `{...}`. 

Но что, если объекты создаются функцией-конструктором через `new`?  Как указать прототип в этом случае?
[cut]

## Свойство F.prototype

Самым очевидным решением является назначение `__proto__` в конструкторе.

Например, если я хочу, чтобы у всех объектов, которые создаются `new Rabbit`, был прототип `animal`, я могу сделать так:

```js
//+ run
var animal = { eats: true }

function Rabbit(name) {
  this.name = name;
*!*
  this.__proto__ = animal;
*/!*
}

var rabbit = new Rabbit("Кроль");

alert( rabbit.eats ); // true, из прототипа
```

Недостаток этого подхода -- он не работает в IE10-. 

К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ.

**Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство `prototype`.**

**При создании объекта через `new`, в его прототип `__proto__` записывается ссылка из `prototype` функции-конструктора.**

Например, код ниже полностью аналогичен предыдущему, но работает всегда и везде:

```js
//+ run
var animal = { eats: true };

function Rabbit(name) { 
  this.name = name;
}

*!*
Rabbit.prototype = animal;
*/!*

var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true
```

Установка `Rabbit.prototype = animal` буквально говорит интерпретатору следующее: *"При создании объекта через `new Rabbit` запиши ему `__proto__  = animal`".* 

[smart header="Свойство `prototype` имеет смысл только у конструктора"]
Свойство `prototype` можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.

Само по себе оно вообще ничего не делает, его единственное назначение -- ставить `__proto__` новым объектам.
[/smart]



[warn header="Значением `prototype` может быть только объект"]
Технически, в это свойство можно записать что угодно.

Однако, при работе `new`, свойство `prototype` будет использовано лишь в том случае, если это объект. Примитивное значение, такое как число или строка, будет проигнорировано. 
[/warn]

## Эмуляция Object.create для IE8- [#inherit]

Как мы только что видели, с конструкторами всё просто, назначить прототип можно кросс-браузерно при помощи `F.prototype`.

Теперь вернёмся к созданию объектов без конструктора.

Мы знаем, что в этом случае можно указывать прототип при помощи `__proto__`, но это не работает в IE10-. Также мы знаем, что есть метод `Object.create(proto)`, который создаёт пустой объект с данным прототипом, но он не работает в IE8-. 

**Используя `prototype`, вызов `Object.create` можно легко эмулировать, так что он будет работать во всех браузерах, включая даже очень-очень старые.**

Кросс-браузерный аналог -- назовём его `inherit`, состоит буквально из нескольких строк:

```js
function inherit(proto) {
  function F() {}
  F.prototype = proto;
  var object = new F;
  return object;
}
```

Результат вызова `inherit(animal)` идентичен `Object.create(animal)`. Это будет новый пустой объект с прототипом `animal`.

Например:

```js
//+ run
var animal = { eats: true };

var rabbit = inherit(animal); 
 
alert(rabbit.eats); // true
```

Посмотрите внимательно на функцию `inherit` и вы, наверняка, сами поймёте, как она работает...
 
Давайте, на всякий случай, пройдём её по шагам:

```js
function inherit(proto) {
  function F() {}     // (1)
  F.prototype = proto // (2)
  var object = new F; // (3)
  return object;      // (4)
}
```

<ol>
<li>Создана новая функция `F`. Она ничего не делает с `this`, так что если вызвать `new F`, то получим пустой объект.</li>
<li>Свойство `F.prototype` устанавливается в будущий прототип `proto`</li>
<li>Результатом вызова `new F` будет пустой объект с `__proto__` равным значению `F.prototype`.</li>
<li>Мы получили пустой объект с заданным прототипом, как и хотели. Возвратим его.</li>
</ol>


Эта функция широко используется в библиотеках и фреймворках.

Здесь и далее мы будем использовать `Object.create`, предполагая что для IE8- выполнен код:

```js
if (!Object.create) Object.create = inherit; /* определение inherit - выше */
```

В частности, аналогичным образом работает библиотека [es5-shim](https://github.com/es-shims/es5-shim), при подключении которой `Object.create` станет доступен для всех браузеров.

## Итого

<ul>
<li>Прототип новых объектов, создаваемых через `new`, можно задавать кросс-браузерно, при помощи свойства конструктора `prototype`.</li>
<li>При создании объекта через `new F`, в его `__proto__` записывается ссылка на объект `F.prototype`.</li>
<li>Современный метод `Object.create(proto)` можно эмулировать его при помощи `prototype`, если хочется, чтобы он работал в IE8-.</li>
</ul>



[head]
<script>
function inherit(proto) {
  function F() {}     
  F.prototype = proto;
  return new F();
}
</script>
[/head]